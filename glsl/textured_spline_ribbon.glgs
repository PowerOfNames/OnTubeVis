#version 460

/* 0: All attributes in geom->frag interface
   1: No curve attributes in geom->frag interface
   2: No color attributes in geom->frag interface
   3: Attribute-less (except segment and sub-curve ids) */
#define ATTRIB_MODE 1

#define ONE_OVER_THREE (1.0/3.0)
#define N0 3
#define NUM_SUBDIVISIONS 4
#define NUM_VERTICES (2 * 2 * NUM_SUBDIVISIONS)

//***** begin interface of view.glsl ***********************************
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
//***** end interface of view.glsl ***********************************

struct TubeNode {
	vec3 pos;
	float rad;

	vec3 pos_tan;
	float rad_tan;
};

struct Tube {
	TubeNode s;
	TubeNode e;
};

struct QTubeNode {
	vec3 pos;
	float rad;
};

struct QTube {
	QTubeNode s;
	QTubeNode h;
	QTubeNode e;
};

layout(points) in;
layout(triangle_strip, max_vertices = NUM_VERTICES) out;

struct node_data_type {
	vec4 pos_rad;
	vec4 color;
	vec4 tangent;
	vec4 t; // only uses .x component to store t, yzw are reserved for future use
};

layout(std430, binding = 0) readonly buffer data_buffer {
    node_data_type nodes[];
};

uniform float radius_scale;
uniform vec3 cyclopic_eye;
uniform vec3 view_dir;
uniform vec4 viewport;
uniform float max_t;

const vec3 eye_pos = (get_inverse_modelview_matrix()*vec4(0, 0, 0, 1)).xyz;

in flat uvec2 node_ids_gs[];
in flat int segment_id_gs[];

out vec3 position_fs;
out vec3 normal_fs;
out vec2 texcoords_fs;
out flat float l_offset_fs;
#if !(ATTRIB_MODE & 2)
	out flat uint color0_fs;
	out flat uint color1_fs;
#endif
#if !(ATTRIB_MODE & 1)
	out flat QTube qTube_fs;
#endif
out flat int segment_id_fs;
out flat mat4 SM_fs; // spline matrix

#define DEF_SplitCurve(T)						\
void SplitCurve(T v0, T d0, T v1, T d1,			\
	out T v00_out, out T h0_out, out T v10_out,	\
	out T v01_out, out T h1_out, out T v11_out)	\
{												\
	v00_out = v0;								\
	h0_out = v0 + d0 * 0.2667/*ONE_OVER_THREE*/;	\
	T h1 = v1 - d1 * 0.2667/*ONE_OVER_THREE*/;	\
	v10_out = (h0_out + h1) * 0.5;				\
												\
	v01_out = v10_out;							\
	h1_out = h1;								\
	v11_out = v1;								\
}

DEF_SplitCurve(float)
DEF_SplitCurve(vec3)

#define SPLIT_CURVE(TUBE, MEM_V, MEM_D, QTUBE0, QTUBE1)		\
SplitCurve(													\
	TUBE.s.MEM_V, TUBE.s.MEM_D, TUBE.e.MEM_V, TUBE.e.MEM_D,	\
	QTUBE0.s.MEM_V, QTUBE0.h.MEM_V, QTUBE0.e.MEM_V,			\
	QTUBE1.s.MEM_V, QTUBE1.h.MEM_V, QTUBE1.e.MEM_V			\
)

void SplitTube(Tube tube, out QTube qTube0, out QTube qTube1)
{
	SPLIT_CURVE(tube, pos, pos_tan, qTube0, qTube1);
	SPLIT_CURVE(tube, rad, rad_tan, qTube0, qTube1);
}

void SplinePointsToPolyCoeffs(float p0, float h, float p1, out float o_c[3])
{
	o_c[0] = p0;
	o_c[1] = -2.0 * p0 + 2.0 * h;
	o_c[2] =   p0 + p1 - 2.0 * h;
}

float EvalPolyD0(float x, float c[3]) {

	return x * (x * c[2] + c[1]) + c[0];
}

vec3 qSplineEval(float l, float curveX[N0], float curveY[N0], float curveZ[N0]) {
	return vec3(
		EvalPolyD0(l, curveX), 
		EvalPolyD0(l, curveY), 
		EvalPolyD0(l, curveZ)
	);
}

vec3 eval_cubic_hermite_tangent(float t) {
	vec4 tvec = vec4(3.0*t*t, 2.0*t, 1.0, 0.0);
	return (SM_fs * tvec).xyz;
}

void emit_ribbon_segment(int segment_idx, QTube qTube, float start_t, float end_t) {
	
	const mat4 MV = get_modelview_matrix();

	#if !(ATTRIB_MODE & 1)
		qTube_fs.s.pos = (MV * vec4(qTube.s.pos, 1.0)).xyz;
		qTube_fs.h.pos = (MV * vec4(qTube.h.pos, 1.0)).xyz;
		qTube_fs.e.pos = (MV * vec4(qTube.e.pos, 1.0)).xyz;
		qTube_fs.s.rad = qTube.s.rad;
		qTube_fs.h.rad = qTube.h.rad;
		qTube_fs.e.rad = qTube.e.rad;
	#endif

	l_offset_fs = segment_idx == 0 ? 0.0 : 0.5;

	vec3 s = qTube.s.pos;
	vec3 h = qTube.h.pos;
	vec3 t = qTube.e.pos;

	float curveX[N0]; SplinePointsToPolyCoeffs(s.x, h.x, t.x, curveX);
	float curveY[N0]; SplinePointsToPolyCoeffs(s.y, h.y, t.y, curveY);
	float curveZ[N0]; SplinePointsToPolyCoeffs(s.z, h.z, t.z, curveZ);
	
	float radius = qTube.s.rad;

	mat4 MVP = get_modelview_projection_matrix();
	mat3 NM = get_normal_matrix();

	float end_l = 1.0;

	if(max_t < end_t)
		end_l = (max_t - start_t) / (end_t - start_t);

	for(int i = 0; i < NUM_SUBDIVISIONS; ++i) {
		// the quadratic spline runlength parameter in [0,1]
		float qspline_l = float(i)/float(NUM_SUBDIVISIONS-1);
		qspline_l *= end_l;
		
		// transform to cubic spline parameter
		float spline_t = 0.5 * qspline_l + l_offset_fs;

		// tangent is given in object space (always use cubic tangents)
		vec3 tangent = eval_cubic_hermite_tangent(spline_t);
		
		// compute the position on the quadratic spline at the current runlength parameter
		vec3 spline_pos = qSplineEval(qspline_l, curveX, curveY, curveZ);

		// calculate a bitangent which is orthogonal to the tangent and the vector from the eye position to the spline position
		vec3 b = normalize(cross(tangent, spline_pos - cyclopic_eye));
		
		// compute the normal from the tangent and bitangent and transform to eye space
		vec3 normal = cross(tangent, b);
		normal = normalize(NM * normal);
		normal_fs = normal;

		// get vertex positios by extruding the spline outwards along the direction of the (view-aligned) bitangent
		vec3 c0 = spline_pos + b * radius;
		vec3 c1 = spline_pos - b * radius;
		
		position_fs = (MV * vec4(c0, 1.0)).xyz;
		texcoords_fs = vec2(spline_t, 0.0);
		gl_Position = MVP * vec4(c0, 1.0); EmitVertex();

		position_fs = (MV * vec4(c1, 1.0)).xyz;
		texcoords_fs = vec2(spline_t, 1.0);
		gl_Position = MVP * vec4(c1, 1.0); EmitVertex();
	}

	EndPrimitive();
}

void main()
{
	Tube tube;
	
	node_data_type n0 = nodes[node_ids_gs[0].x];
	
	tube.s.pos = n0.pos_rad.xyz;
	tube.s.rad = n0.pos_rad.w * radius_scale;
	tube.s.pos_tan = n0.tangent.xyz;
	tube.s.rad_tan = n0.tangent.w;

	node_data_type n1 = nodes[node_ids_gs[0].y];
	
	tube.e.pos = n1.pos_rad.xyz;
	tube.e.rad = n1.pos_rad.w * radius_scale;
	tube.e.pos_tan = n1.tangent.xyz;
	tube.e.rad_tan = n1.tangent.w;
	
	QTube qTube0, qTube1;
	SplitTube(tube, qTube0, qTube1);
	
	segment_id_fs = segment_id_gs[0];

	mat4 Bk; // matrix of control points and tangents
	Bk[0] = vec4(tube.s.pos, 0.0);
	Bk[1] = vec4(tube.e.pos, 0.0);
	Bk[2] = vec4(tube.s.pos_tan, 0.0);
	Bk[3] = vec4(tube.e.pos_tan, 0.0);

	mat4 Mh; // hermite matrix
	Mh[0] = vec4( 2, -2,  1,  1);
	Mh[1] = vec4(-3,  3, -2, -1);
	Mh[2] = vec4( 0,  0,  1,  0);
	Mh[3] = vec4( 1,  0,  0,  0);
	SM_fs = Bk * Mh;

#if !(ATTRIB_MODE & 2)
	color0_fs = packUnorm4x8(vec4(n0.color.rgb, 1.0));
	color1_fs = packUnorm4x8(vec4(n1.color.rgb, 1.0));
#endif

	float split_t = 0.5 * (n0.t.x + n1.t.x);
	
	// TODO: use one ribbon for both segments?
	if (n0.t.x < max_t)
	{
		emit_ribbon_segment(0, qTube0, n0.t.x, split_t);
		if (0.5*(n0.t.x + n1.t.x) < max_t)
			emit_ribbon_segment(1, qTube1, split_t, n1.t.x);
	}
}
