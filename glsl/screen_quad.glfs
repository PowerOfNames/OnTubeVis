#version 430

//***** begin interface of view.glsl ***********************************
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
//***** end interface of view.glsl ***********************************

////***** begin interface of surface.glsl ***********************************
vec4 compute_reflected_appearance(vec3 position_eye, vec3 normal_eye, vec4 color, int side);
////***** end interface of surface.glsl ***********************************

layout (binding = 0) uniform sampler2D albedo_tex;
layout (binding = 1) uniform sampler2D position_tex;
layout (binding = 2) uniform sampler2D normal_tex;
layout (binding = 3) uniform sampler2D texcoord_tex;
layout (binding = 4) uniform sampler2D depth_tex;
layout (binding = 5) uniform sampler2D test_tex;
layout (binding = 6) uniform sampler3D density_tex;

//uniform vec3 background_color;

uniform bool use_gamma = false;

uniform struct {
	bool enable;
	float sample_offset;
	float sample_distance;
	float strength_scale;
	vec3 tex_offset;
	vec3 tex_scaling;
	vec3 texcoord_scaling;
	float texel_size;
	float cone_angle_factor;
	vec3 sample_directions[3];
} ambient_occlusion;

in vec2 texcoord_fs;

out vec4 frag_color;

void main()
{
	vec4 color = vec4(texture(albedo_tex, texcoord_fs).rgb, 1.0);
	vec3 pos_eye = texture(position_tex, texcoord_fs).xyz;
	vec3 normal_value = texture(normal_tex, texcoord_fs).xyz;
	vec3 normal_eye = 2.0 * normal_value - 1.0;
	vec2 texcoord = texture(texcoord_tex, texcoord_fs).rg;
	vec3 tex_color = texture(test_tex, texcoord).rgb;
	
	//frag_color = vec4(vec3(color.rgb), 1.0);

	if(normal_value.x + normal_value.y + normal_value.z < 0.00001f) {
		//finish_fragment(vec4(background_color, 1.0));
		vec3 background_color = vec3(0.0);
		frag_color = vec4(background_color, 1.0);
	} else {
		frag_color = compute_reflected_appearance(pos_eye, normal_eye, color, 1);
		//frag_color = vec4(texcoord.s, texcoord.t, 0.0, 1.0);
		frag_color = vec4(tex_color, 1.0);
		//frag_color = vec4(1.0);
		//frag_color = vec4(normal_value, 1.0);
	
		if(ambient_occlusion.enable) {
			vec3 pos = (get_inverse_modelview_matrix() * vec4(pos_eye, 1.0)).xyz;
			vec3 normal = normalize(get_inverse_normal_matrix() * normal_eye);

			// do voxel cone tracing to determine occlusion of ambient light
			float ao = 0.0;

			mat3 R;
			R[1] = normal;
			R[0] = cross(R[1], normalize(pos));
			R[2] = cross(R[0], R[1]);

			//vec3 new_y = normal;
			//vec3 new_x = cross(new_y, normalize(pos));
			//vec3 new_z = cross(new_x, new_y);

			for(int i = 0; i < 3; ++i) {
				vec3 sd = R * ambient_occlusion.sample_directions[i];

				float sample_distance = ambient_occlusion.sample_offset + 0.001;
				vec3 normalized_pos = (pos - ambient_occlusion.tex_offset) * ambient_occlusion.tex_scaling;
				float lod_texel_size = 0.0f;
			
				float illumination = 1.0;

				do {
					// get cone base radius at current distance and then the according mipmap sample level
					float cone_radius = sample_distance * ambient_occlusion.cone_angle_factor;
					float sample_level = clamp(log2(cone_radius / ambient_occlusion.texel_size), 0.0, 7.0);

					lod_texel_size = pow(2.0, sample_level) * ambient_occlusion.texel_size;

					vec3 sample_pos = normalized_pos + sample_distance * sd * ambient_occlusion.texcoord_scaling;
					float density = textureLod(density_tex, sample_pos, sample_level).r;
					// apply the compositing function
					illumination *= 1.0 - density * illumination;

					// get the next sample distance and position
					sample_distance += cone_radius;
				} while(sample_distance < ambient_occlusion.sample_distance - lod_texel_size && illumination > 0.02);

				ao += (1.0 - illumination);
			}

			float ao_factor = 1.0 - clamp(ambient_occlusion.strength_scale * ao / 3.0, 0.0, 1.0);
			frag_color.rgb *= ao_factor;
		}
	}

	//frag_color = texture(albedo_tex, texcoord_fs);
	//frag_color = texture(position_tex, texcoord_fs);
	//frag_color = texture(normal_tex, texcoord_fs);
	//frag_color = texture(texcoord_tex, texcoord_fs);
	
	//frag_color.rgb = frag_color.rgb + frag_color.a * pow(background_color, vec3(2.2));
	//frag_color.a = 1.0;
	if(use_gamma)
		frag_color.rgb = pow(frag_color.rgb, vec3(2.2));
	
	//frag_color = texture(depth_tex, texcoord_fs).rrrr;

	// write the frag depth to enable the framework view to work properly
	gl_FragDepth = texture(depth_tex, texcoord_fs).r;
}