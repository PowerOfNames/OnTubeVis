#version 460

#define USE_CONSERVATIVE_DEPTH 0

#define ONE_OVER_THREE 1.0 / 3.0

//***** begin interface of view.glsl ***********************************
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
//***** end interface of view.glsl ***********************************

const vec4 corners[4] = {
	vec4(-0.5, +0.0, +0.0, 1.0),
	vec4(+0.5, +0.0, +0.0, 1.0),
	vec4(-0.5, +0.5, +0.0, 1.0),
	vec4(-0.5, +0.0, +0.5, 1.0)
};

struct TubeNode {
	vec3 pos;
	float rad;

	vec3 pos_tan;
	float rad_tan;
};

struct Tube {
	TubeNode s;
	TubeNode e;
};

struct QTubeNode {
	vec3 pos;
	float rad;
};

struct QTube {
	QTubeNode s;
	QTubeNode h;
	QTubeNode e;
};

layout(lines) in;
layout(triangle_strip, max_vertices = 8) out;

uniform vec3 eye_pos;
uniform vec3 view_dir;

in flat vec4 tangent_gs[];
in flat vec4 color_gs[];
in flat int vertex_id_gs[];

out vec3 position_fs;
out flat float l_offset_fs;
out flat vec3 color0_fs;
out flat vec3 color1_fs;
out flat QTube qTube_fs;
out flat mat4 mg_fs;
out flat int segment_id_fs;

float saturate(float x) { return clamp(x, 0.0, 1.0); }

vec3 project_to_plane(vec3 vec, vec3 n) {

	return vec - n * dot(vec, n) / dot(n, n);
}

// returns a non-normalized vector orthogonal to the input v
// source: http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts
vec3 ortho_vec(vec3 v) {

    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y);
}

#define DEF_EvalCSplineMidPoint(T)					\
void EvalCSplineMidPoint(T p1, T t1, T p2, T t2,	\
	out T out_p, out T out_t)						\
{													\
	T h1 = p1 + t1 * ONE_OVER_THREE;				\
	T h2 = p2 - t2 * ONE_OVER_THREE;				\
													\
	T a1 = (p1 + h1) * 0.5;							\
	T a2 = (h1 + h2) * 0.5;							\
	T a3 = (h2 + p2) * 0.5;							\
													\
	T b1 = (a1 + a2) * 0.5;							\
	T b2 = (a2 + a3) * 0.5;							\
													\
	out_t = (b2 - b1) * 3.0;						\
	out_p = (b1 + b2) * 0.5;						\
}

DEF_EvalCSplineMidPoint(float)
DEF_EvalCSplineMidPoint(vec3)

#define DEF_SplitCurve(T)						\
void SplitCurve(T v0, T d0, T v1, T d1,			\
	out T v00_out, out T h0_out, out T v10_out,	\
	out T v01_out, out T h1_out, out T v11_out)	\
{												\
	v00_out = v0;								\
	h0_out = v0 + d0 * 0.25;					\
	T h1 = v1 - d1 * 0.25;						\
	v10_out = (h0_out + h1) * 0.5;				\
												\
	v01_out = v10_out;							\
	h1_out = h1;								\
	v11_out = v1;								\
}

DEF_SplitCurve(float)
DEF_SplitCurve(vec3)

#define SPLIT_CURVE(TUBE, MEM_V, MEM_D, QTUBE0, QTUBE1)		\
SplitCurve(													\
	TUBE.s.MEM_V, TUBE.s.MEM_D, TUBE.e.MEM_V, TUBE.e.MEM_D,	\
	QTUBE0.s.MEM_V, QTUBE0.h.MEM_V, QTUBE0.e.MEM_V,			\
	QTUBE1.s.MEM_V, QTUBE1.h.MEM_V, QTUBE1.e.MEM_V			\
)

void SplitTube(Tube tube, out QTube qTube0, out QTube qTube1)
{
	SPLIT_CURVE(tube, pos, pos_tan, qTube0, qTube1);
	SPLIT_CURVE(tube, rad, rad_tan, qTube0, qTube1);
}

void SplinePointsToPolyCoeffs(float p0, float h, float p1, out float o_c[3])
{
	o_c[0] = p0;
	o_c[1] = -2.0 * p0 + 2.0 * h;
	o_c[2] =   p0 + p1 - 2.0 * h;
}

float EvalPolyD0(float x, float c[3]) {

	return x * (x * c[2] + c[1]) + c[0];
}

mat4 calculate_transformation_matrix(QTube qTube) {

	vec3 x, y, z;
	float xl, yl;
	bool xq = false;
	bool yq = false;
	{
		x = qTube.e.pos - qTube.s.pos;
		xl = length(x);
		
		if(xl < 0.0001) {
			y = qTube.h.pos - qTube.s.pos;
			yl = length(y);
			
			if(yl < 0.0001) {
				x = vec3(1.0, 0.0, 0.0);
				y = vec3(0.0, 1.0, 0.0);
				z = vec3(0.0, 0.0, 1.0);
				
				xl = 1.0; xq = true;
				yl = 1.0; yq = true;
			} else {
				x = normalize(ortho_vec(x));
				xl = 1.0; xq = true;
				
				z = cross(x, y);
			}
		} else {
			y = project_to_plane(qTube.h.pos - qTube.s.pos, x);
			yl = length(y);
			
			if(yl < 0.0001) {
				y = normalize(ortho_vec(x));
				yl = 1.0; yq = true;
			}
			
			z = cross(x, y);
		}
	}	

	vec3 xd = x / xl;
	vec3 yd = y / yl;
	vec3 zd = normalize(z);
	
	float xm, xp, ym, yp, zm;
	{
		float xyl = dot(qTube.h.pos - qTube.s.pos, xd);
		
		float cx[3];
		SplinePointsToPolyCoeffs(0.0, xyl, xl, cx);
		
		float cy[3];
		SplinePointsToPolyCoeffs(0.0, yl, 0.0, cy);
		
		float rc[3];
		SplinePointsToPolyCoeffs(qTube.s.rad, qTube.h.rad, qTube.e.rad, rc);
		
		float c_xm[3];
		c_xm[0] = cx[0] - rc[0]; c_xm[1] = cx[1] - rc[1]; c_xm[2] = cx[2] - rc[2];
		
		float c_xp[3];
		c_xp[0] = cx[0] + rc[0]; c_xp[1] = cx[1] + rc[1]; c_xp[2] = cx[2] + rc[2];
		
		xm = min(-qTube.s.rad, min(xl - qTube.e.rad, EvalPolyD0(saturate(-c_xm[1] / c_xm[2] * 0.5), c_xm)));
		xp = max( qTube.s.rad, max(xl + qTube.e.rad, EvalPolyD0(saturate(-c_xp[1] / c_xp[2] * 0.5), c_xp)));
		
		float c_ym[3];
		c_ym[0] = cy[0] - rc[0]; c_ym[1] = cy[1] - rc[1]; c_ym[2] = cy[2] - rc[2];
		
		float c_yp[3];
		c_yp[0] = cy[0] + rc[0]; c_yp[1] = cy[1] + rc[1]; c_yp[2] = cy[2] + rc[2];
		
		ym = min(-qTube.s.rad, min(-qTube.e.rad, EvalPolyD0(saturate(-c_ym[1] / c_ym[2] * 0.5), c_ym)));
		yp = max( qTube.s.rad, max( qTube.e.rad, EvalPolyD0(saturate(-c_yp[1] / c_yp[2] * 0.5), c_yp)));
		
		zm = max( qTube.s.rad, max( qTube.e.rad, EvalPolyD0(saturate(-rc[1] / rc[2] * 0.5), rc)));
		
		if(xq) { xm = -zm; xp = zm; }
		if(yq) { ym = -zm; yp = zm; }
	}
	
	vec3 center = qTube.s.pos + 0.5*(xd * (xm + xp) + yd * (ym + yp));

	mat4 M;
	M[0] = vec4((xp - xm) * xd, 0.0);
	M[1] = vec4((yp - ym) * yd, 0.0);
	M[2] = vec4(2.0 * zm  * zd, 0.0);
	M[3] = vec4(center, 1.0);
	
	return M;
}

mat4x3 quad(vec4 start, vec4 end) {

	vec3 ps = start.xyz;
	vec3 pe = end.xyz;
	vec2 rse = vec2(start.w, end.w);
	vec3 delta = normalize(pe - ps);

	vec3 start_to_eye = eye_pos - ps;
	vec3 end_to_eye   = eye_pos - pe;
	
	vec2 dse = vec2(length(start_to_eye), length(end_to_eye));

	vec2 pr_fac = rse / sqrt(dse*dse - rse*rse);

	vec2 pr = dse * pr_fac;

	start_to_eye /= dse.x;
	end_to_eye /= dse.y;

	vec2 pr2 = dse * vec2(max(pr_fac.x, pr_fac.y));

	vec3 aligned_up = normalize(cross(delta, start_to_eye));
	vec3 bitangent0 = cross(aligned_up, start_to_eye); // aligned_up and start_to_eye are perpendicular and unit vectors, so no normalization is needed
	vec3 bitangent1 = cross(aligned_up, end_to_eye); // same as for bitangent0

	vec3 p0 = ps + pr.x * bitangent0;
	vec3 p1 = ps - pr.x * bitangent0;
	vec3 p2 = pe + pr.y * bitangent1;
	vec3 p3 = pe - pr.y * bitangent1;

	vec3 test_dir = normalize(cross(aligned_up, view_dir));

	float mag0 = dot(normalize(p0 - eye_pos), test_dir);
	float mag1 = dot(normalize(p1 - eye_pos), test_dir);
	float mag2 = dot(normalize(p2 - eye_pos), test_dir);
	float mag3 = dot(normalize(p3 - eye_pos), test_dir);

	vec3 a = p0;
	vec3 b = p3;
	vec2 rab = pr2;

	if(mag0 > mag2) {
		a = p2;
		rab.x = pr2.y;
	}

	if(mag1 > mag3) {
		b = p1;
		rab.y = pr2.x;
	}

	mat4x3 ret;
	ret[0] = a - rab.x * aligned_up;
	ret[1] = a + rab.x * aligned_up;
	ret[2] = b - rab.y * aligned_up;
	ret[3] = b + rab.y * aligned_up;

	return ret;
}

/*
	Rounded cone signed distance function from:
	https://iquilezles.org/www/articles/distfunctions/distfunctions.htm
*/
float sd_rounded_cone(vec3 p, vec4 a, vec4 b) {
    // sampling independent computations (only depend on shape)
    vec3  ba = b.xyz - a.xyz;
    float l2 = dot(ba,ba);
    float rr = a.w - b.w;
    float a2 = l2 - rr*rr;
    float il2 = 1.0/l2;
    
    // sampling dependant computations
    vec3 pa = p - a.xyz;
    float y = dot(pa,ba);
    float z = y - l2;
	vec3 v = pa*l2 - ba*y;
    float x2 = dot(v, v);
    float y2 = y*y*l2;
    float z2 = z*z*l2;

    float k = sign(rr)*rr*rr*x2;

    if(sign(z)*a2*z2 > k)
		return sqrt(x2 + z2) * il2 - b.w;

    if(sign(y)*a2*y2 < k)
		return sqrt(x2 + y2) * il2 - a.w;
    
	return (sqrt(x2*a2*il2) + y*rr) * il2 - a.w;
}

void emit_quad(int segment_idx, QTube qTube) {

	mat4 M = calculate_transformation_matrix(qTube);
	vec4 p000 = M * corners[0];
	vec4 p100 = M * corners[1];
	vec4 p010 = M * corners[2];
	vec4 p001 = M * corners[3];

	vec4 dy = p010 - p000;
	vec4 dz = p001 - p000;

	float r = max(length(dy), length(dz));

	vec4 sp = p000;
	vec4 ep = p100;
	sp.w = r;
	ep.w = r;

	mat4x3 ps = quad(sp, ep);

#if USE_CONSERVATIVE_DEPTH == 1
	float dist = sd_rounded_cone(eye_pos, sp, ep);
	ps[0] = eye_pos + dist*normalize(ps[0] - eye_pos);
	ps[1] = eye_pos + dist*normalize(ps[1] - eye_pos);
	ps[2] = eye_pos + dist*normalize(ps[2] - eye_pos);
	ps[3] = eye_pos + dist*normalize(ps[3] - eye_pos);
#endif

	qTube.s.pos = (get_modelview_matrix() * vec4(qTube.s.pos, 1.0)).xyz;
	qTube.h.pos = (get_modelview_matrix() * vec4(qTube.h.pos, 1.0)).xyz;
	qTube.e.pos = (get_modelview_matrix() * vec4(qTube.e.pos, 1.0)).xyz;
	qTube_fs = qTube;

	l_offset_fs = segment_idx == 0 ? 0.0 : 0.5;

	vec4 p00 = get_modelview_matrix() * vec4(ps[0], 1.0);
	vec4 p10 = get_modelview_matrix() * vec4(ps[1], 1.0);
	vec4 p01 = get_modelview_matrix() * vec4(ps[2], 1.0);
	vec4 p11 = get_modelview_matrix() * vec4(ps[3], 1.0);

	mat4 PM = get_projection_matrix();

	position_fs = p00.xyz;
	gl_Position = PM * p00; EmitVertex();
	position_fs = p10.xyz;
	gl_Position = PM * p10; EmitVertex();
	position_fs = p01.xyz;
	gl_Position = PM * p01; EmitVertex();
	position_fs = p11.xyz;
	gl_Position = PM * p11; EmitVertex();
	EndPrimitive();
}

void main()
{
	Tube tube;
	tube.s.pos = gl_in[0].gl_Position.xyz;
	tube.s.rad = gl_in[0].gl_Position.w;
	tube.s.pos_tan = tangent_gs[0].xyz;
	tube.s.rad_tan = tangent_gs[0].w;

	tube.e.pos = gl_in[1].gl_Position.xyz;
	tube.e.rad = gl_in[1].gl_Position.w;
	tube.e.pos_tan = tangent_gs[1].xyz;
	tube.e.rad_tan = tangent_gs[1].w;

	color0_fs = color_gs[0].rgb;
	color1_fs = color_gs[1].rgb;

	QTube qTube0, qTube1;
	SplitTube(tube, qTube0, qTube1);
	


	


	mat4 geometrymatrix;
	geometrymatrix[0] = vec4(tube.s.pos, 0.0);
	geometrymatrix[1] = vec4(tube.e.pos, 0.0);
	geometrymatrix[2] = vec4(tube.s.pos_tan, 0.0);
	geometrymatrix[3] = vec4(tube.e.pos_tan, 0.0);


	mat4 Mh;
	Mh[0] = vec4( 2, -2,  1,  1);
	Mh[1] = vec4(-3,  3, -2, -1);
	Mh[2] = vec4( 0,  0,  1,  0);
	Mh[3] = vec4( 1,  0,  0,  0);
	mg_fs = geometrymatrix * Mh;

	
	
	// gl_PrimitiveIDIn cannot be used since it changes depending on the primitve order, which is influenced by visibility sorting
	segment_id_fs = gl_PrimitiveIDIn;
	segment_id_fs = vertex_id_gs[0];




	emit_quad(0, qTube0);
	emit_quad(1, qTube1);
}
