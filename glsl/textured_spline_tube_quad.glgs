#version 460

#define USE_CONSERVATIVE_DEPTH 0
#define USE_CUBIC_TANGENTS 1
/*
	0: BOX
	1: APPROXIMATE_BILLBOARD
	2: EXACT_POLYGON
	3: BOX_BILLBOARD
*/
#define BOUNDING_GEOMETRY_TYPE 1

#define ONE_OVER_THREE 1.0 / 3.0

//***** begin interface of view.glsl ***********************************
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
//***** end interface of view.glsl ***********************************

const vec4 corners[4] = {
	vec4(-0.5, +0.0, +0.0, 1.0),
	vec4(+0.5, +0.0, +0.0, 1.0),
	vec4(-0.5, +0.5, +0.0, 1.0),
	vec4(-0.5, +0.0, +0.5, 1.0)
};

const vec4 corners2[4] = {
	vec4(-0.5, -0.5, -0.5, 1.0),
	vec4(+0.5, -0.5, -0.5, 1.0),
	vec4(-0.5, +0.5, -0.5, 1.0),
	vec4(-0.5, -0.5, +0.5, 1.0)
};

struct TubeNode {
	vec3 pos;
	float rad;

	vec3 pos_tan;
	float rad_tan;
};

struct Tube {
	TubeNode s;
	TubeNode e;
};

struct QTubeNode {
	vec3 pos;
	float rad;
};

struct QTube {
	QTubeNode s;
	QTubeNode h;
	QTubeNode e;
};

layout(points) in;
#if BOUNDING_GEOMETRY_TYPE == 0
layout(triangle_strip, max_vertices = 14) out;
#elif BOUNDING_GEOMETRY_TYPE == 1
layout(triangle_strip, max_vertices = 8) out;
#elif BOUNDING_GEOMETRY_TYPE == 2
layout(triangle_strip, max_vertices = 12) out;
#else
layout(triangle_strip, max_vertices = 8) out;
#endif

struct node_data_type {
	vec4 pos_rad;
	vec4 color;
	vec4 tangent;
};

layout(std430, binding = 0) readonly buffer data_buffer {
    node_data_type nodes[];
};

uniform float radius_scale;
uniform vec3 eye_pos;
uniform vec3 view_dir;

in flat uvec2 node_ids_gs[];
in flat int segment_id_gs[];

out vec3 position_fs;
out flat float l_offset_fs;
out flat vec3 color0_fs;
out flat vec3 color1_fs;
out flat QTube qTube_fs;
out flat int segment_id_fs;
#if USE_CUBIC_TANGENTS == 1
out flat mat4 SM_fs; // spline matrix
#endif

float saturate(float x) { return clamp(x, 0.0, 1.0); }

vec3 project_to_plane(vec3 vec, vec3 n) {

	return vec - n * dot(vec, n) / dot(n, n);
}

// returns a non-normalized vector orthogonal to the input v
// source: http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts
vec3 ortho_vec(vec3 v) {

    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y);
}

#define DEF_EvalCSplineMidPoint(T)					\
void EvalCSplineMidPoint(T p1, T t1, T p2, T t2,	\
	out T out_p, out T out_t)						\
{													\
	T h1 = p1 + t1 * ONE_OVER_THREE;				\
	T h2 = p2 - t2 * ONE_OVER_THREE;				\
													\
	T a1 = (p1 + h1) * 0.5;							\
	T a2 = (h1 + h2) * 0.5;							\
	T a3 = (h2 + p2) * 0.5;							\
													\
	T b1 = (a1 + a2) * 0.5;							\
	T b2 = (a2 + a3) * 0.5;							\
													\
	out_t = (b2 - b1) * 3.0;						\
	out_p = (b1 + b2) * 0.5;						\
}

DEF_EvalCSplineMidPoint(float)
DEF_EvalCSplineMidPoint(vec3)

#define DEF_SplitCurve(T)						\
void SplitCurve(T v0, T d0, T v1, T d1,			\
	out T v00_out, out T h0_out, out T v10_out,	\
	out T v01_out, out T h1_out, out T v11_out)	\
{												\
	v00_out = v0;								\
	h0_out = v0 + d0 * 0.25;					\
	T h1 = v1 - d1 * 0.25;						\
	v10_out = (h0_out + h1) * 0.5;				\
												\
	v01_out = v10_out;							\
	h1_out = h1;								\
	v11_out = v1;								\
}

DEF_SplitCurve(float)
DEF_SplitCurve(vec3)

#define SPLIT_CURVE(TUBE, MEM_V, MEM_D, QTUBE0, QTUBE1)		\
SplitCurve(													\
	TUBE.s.MEM_V, TUBE.s.MEM_D, TUBE.e.MEM_V, TUBE.e.MEM_D,	\
	QTUBE0.s.MEM_V, QTUBE0.h.MEM_V, QTUBE0.e.MEM_V,			\
	QTUBE1.s.MEM_V, QTUBE1.h.MEM_V, QTUBE1.e.MEM_V			\
)

void SplitTube(Tube tube, out QTube qTube0, out QTube qTube1)
{
	SPLIT_CURVE(tube, pos, pos_tan, qTube0, qTube1);
	SPLIT_CURVE(tube, rad, rad_tan, qTube0, qTube1);
}

void SplinePointsToPolyCoeffs(float p0, float h, float p1, out float o_c[3])
{
	o_c[0] = p0;
	o_c[1] = -2.0 * p0 + 2.0 * h;
	o_c[2] =   p0 + p1 - 2.0 * h;
}

float EvalPolyD0(float x, float c[3]) {

	return x * (x * c[2] + c[1]) + c[0];
}

mat4 calculate_transformation_matrix(QTube qTube) {

	vec3 x, y, z;
	float xl, yl;
	bool xq = false;
	bool yq = false;
	{
		x = qTube.e.pos - qTube.s.pos;
		xl = length(x);
		
		if(xl < 0.0001) {
			y = qTube.h.pos - qTube.s.pos;
			yl = length(y);
			
			if(yl < 0.0001) {
				x = vec3(1.0, 0.0, 0.0);
				y = vec3(0.0, 1.0, 0.0);
				z = vec3(0.0, 0.0, 1.0);
				
				xl = 1.0; xq = true;
				yl = 1.0; yq = true;
			} else {
				x = normalize(ortho_vec(x));
				xl = 1.0; xq = true;
				
				z = cross(x, y);
			}
		} else {
			y = project_to_plane(qTube.h.pos - qTube.s.pos, x);
			yl = length(y);
			
			if(yl < 0.0001) {
				y = normalize(ortho_vec(x));
				yl = 1.0; yq = true;
			}
			
			z = cross(x, y);
		}
	}	

	vec3 xd = x / xl;
	vec3 yd = y / yl;
	vec3 zd = normalize(z);
	
	float xm, xp, ym, yp, zm;
	{
		float xyl = dot(qTube.h.pos - qTube.s.pos, xd);
		
		float cx[3];
		SplinePointsToPolyCoeffs(0.0, xyl, xl, cx);
		
		float cy[3];
		SplinePointsToPolyCoeffs(0.0, yl, 0.0, cy);
		
		float rc[3];
		SplinePointsToPolyCoeffs(qTube.s.rad, qTube.h.rad, qTube.e.rad, rc);
		
		float c_xm[3];
		c_xm[0] = cx[0] - rc[0]; c_xm[1] = cx[1] - rc[1]; c_xm[2] = cx[2] - rc[2];
		
		float c_xp[3];
		c_xp[0] = cx[0] + rc[0]; c_xp[1] = cx[1] + rc[1]; c_xp[2] = cx[2] + rc[2];
		
		xm = min(-qTube.s.rad, min(xl - qTube.e.rad, EvalPolyD0(saturate(-c_xm[1] / c_xm[2] * 0.5), c_xm)));
		xp = max( qTube.s.rad, max(xl + qTube.e.rad, EvalPolyD0(saturate(-c_xp[1] / c_xp[2] * 0.5), c_xp)));
		
		float c_ym[3];
		c_ym[0] = cy[0] - rc[0]; c_ym[1] = cy[1] - rc[1]; c_ym[2] = cy[2] - rc[2];
		
		float c_yp[3];
		c_yp[0] = cy[0] + rc[0]; c_yp[1] = cy[1] + rc[1]; c_yp[2] = cy[2] + rc[2];
		
		ym = min(-qTube.s.rad, min(-qTube.e.rad, EvalPolyD0(saturate(-c_ym[1] / c_ym[2] * 0.5), c_ym)));
		yp = max( qTube.s.rad, max( qTube.e.rad, EvalPolyD0(saturate(-c_yp[1] / c_yp[2] * 0.5), c_yp)));
		
		zm = max( qTube.s.rad, max( qTube.e.rad, EvalPolyD0(saturate(-rc[1] / rc[2] * 0.5), rc)));
		
		if(xq) { xm = -zm; xp = zm; }
		if(yq) { ym = -zm; yp = zm; }
	}
	
	vec3 center = qTube.s.pos + 0.5*(xd * (xm + xp) + yd * (ym + yp));

	mat4 M;
	M[0] = vec4((xp - xm) * xd, 0.0);
	M[1] = vec4((yp - ym) * yd, 0.0);
	M[2] = vec4(2.0 * zm  * zd, 0.0);
	M[3] = vec4(center, 1.0);
	
	return M;
}


#if BOUNDING_GEOMETRY_TYPE == 1
/*
	Rounded cone signed distance function from:
	https://iquilezles.org/www/articles/distfunctions/distfunctions.htm
*/
float sd_rounded_cone(vec3 p, vec4 a, vec4 b) {
    // sampling independent computations (only depend on shape)
    vec3  ba = b.xyz - a.xyz;
    float l2 = dot(ba,ba);
    float rr = a.w - b.w;
    float a2 = l2 - rr*rr;
    float il2 = 1.0/l2;
    
    // sampling dependant computations
    vec3 pa = p - a.xyz;
    float y = dot(pa,ba);
    float z = y - l2;
	vec3 v = pa*l2 - ba*y;
    float x2 = dot(v, v);
    float y2 = y*y*l2;
    float z2 = z*z*l2;

    float k = sign(rr)*rr*rr*x2;

    if(sign(z)*a2*z2 > k)
		return sqrt(x2 + z2) * il2 - b.w;

    if(sign(y)*a2*y2 < k)
		return sqrt(x2 + y2) * il2 - a.w;
    
	return (sqrt(x2*a2*il2) + y*rr) * il2 - a.w;
}

#elif BOUNDING_GEOMETRY_TYPE > 1

// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm
float sd_box(vec3 p, vec3 b) {
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}
#endif

mat4x3 quad(vec4 start, vec4 end) {

	vec3 ps = start.xyz;
	vec3 pe = end.xyz;
	vec2 rse = vec2(start.w, end.w);
	vec3 delta = normalize(pe - ps);

	vec3 start_to_eye = eye_pos - ps;
	vec3 end_to_eye   = eye_pos - pe;
	
	vec2 dse = vec2(length(start_to_eye), length(end_to_eye));

	vec2 pr_fac = rse / sqrt(dse*dse - rse*rse);

	vec2 pr = dse * pr_fac;

	start_to_eye /= dse.x;
	end_to_eye /= dse.y;

	vec2 pr2 = dse * vec2(max(pr_fac.x, pr_fac.y));

	vec3 aligned_up = normalize(cross(delta, start_to_eye));
	vec3 bitangent0 = cross(aligned_up, start_to_eye); // aligned_up and start_to_eye are perpendicular and unit vectors, so no normalization is needed
	vec3 bitangent1 = cross(aligned_up, end_to_eye); // same as for bitangent0

	vec3 p0 = ps + pr.x * bitangent0;
	vec3 p1 = ps - pr.x * bitangent0;
	vec3 p2 = pe + pr.y * bitangent1;
	vec3 p3 = pe - pr.y * bitangent1;

	vec3 test_dir = normalize(cross(aligned_up, view_dir));

	float mag0 = dot(normalize(p0 - eye_pos), test_dir);
	float mag1 = dot(normalize(p1 - eye_pos), test_dir);
	float mag2 = dot(normalize(p2 - eye_pos), test_dir);
	float mag3 = dot(normalize(p3 - eye_pos), test_dir);

	vec3 a = p0;
	vec3 b = p3;
	vec2 rab = pr2;

	if(mag0 > mag2) {
		a = p2;
		rab.x = pr2.y;
	}

	if(mag1 > mag3) {
		b = p1;
		rab.y = pr2.x;
	}

	mat4x3 ret;
	ret[0] = a - rab.x * aligned_up;
	ret[1] = a + rab.x * aligned_up;
	ret[2] = b - rab.y * aligned_up;
	ret[3] = b + rab.y * aligned_up;

	return ret;
}

#if BOUNDING_GEOMETRY_TYPE == 0
#elif BOUNDING_GEOMETRY_TYPE == 1

void emit_rounded_cone_billboard(int segment_idx, QTube qTube) {

	mat4 M = calculate_transformation_matrix(qTube);
	vec4 p000 = M * corners[0];
	vec4 p100 = M * corners[1];
	vec4 p010 = M * corners[2];
	vec4 p001 = M * corners[3];

	vec4 dy = p010 - p000;
	vec4 dz = p001 - p000;

	float r = max(length(dy), length(dz));

	vec4 sp = p000;
	vec4 ep = p100;
	sp.w = r;
	ep.w = r;

	mat4x3 ps = quad(sp, ep);

#if USE_CONSERVATIVE_DEPTH == 1
	float dist = sd_rounded_cone(eye_pos, sp, ep);
	ps[0] = eye_pos + dist*normalize(ps[0] - eye_pos);
	ps[1] = eye_pos + dist*normalize(ps[1] - eye_pos);
	ps[2] = eye_pos + dist*normalize(ps[2] - eye_pos);
	ps[3] = eye_pos + dist*normalize(ps[3] - eye_pos);
#endif

	qTube.s.pos = (get_modelview_matrix() * vec4(qTube.s.pos, 1.0)).xyz;
	qTube.h.pos = (get_modelview_matrix() * vec4(qTube.h.pos, 1.0)).xyz;
	qTube.e.pos = (get_modelview_matrix() * vec4(qTube.e.pos, 1.0)).xyz;
	qTube_fs = qTube;

	l_offset_fs = segment_idx == 0 ? 0.0 : 0.5;

	vec4 p00 = get_modelview_matrix() * vec4(ps[0], 1.0);
	vec4 p10 = get_modelview_matrix() * vec4(ps[1], 1.0);
	vec4 p01 = get_modelview_matrix() * vec4(ps[2], 1.0);
	vec4 p11 = get_modelview_matrix() * vec4(ps[3], 1.0);

	mat4 PM = get_projection_matrix();

	position_fs = p00.xyz;
	gl_Position = PM * p00; EmitVertex();
	position_fs = p10.xyz;
	gl_Position = PM * p10; EmitVertex();
	position_fs = p01.xyz;
	gl_Position = PM * p01; EmitVertex();
	position_fs = p11.xyz;
	gl_Position = PM * p11; EmitVertex();
	EndPrimitive();
}

#elif BOUNDING_GEOMETRY_TYPE == 2

void emit_exact_box_polygon(int segment_idx, QTube qTube) {
	mat4 M = calculate_transformation_matrix(qTube);
	vec3 p000 = (M * corners2[0]).xyz;
	vec3 p100 = (M * corners2[1]).xyz;
	vec3 p010 = (M * corners2[2]).xyz;
	vec3 p001 = (M * corners2[3]).xyz;

	vec3 dx = p100 - p000;
	vec3 dy = p010 - p000;
	vec3 dz = p001 - p000;

	vec3 a = p000;
	vec3 b = p000 + 1.0*(dx + dy + dz);
	vec3 org = 0.5*(a + b);

	if(dot(eye_pos - org, dx) < 0) {
		a += dx;
		b -= dx;
		dx = -dx;
	}
	if(dot(eye_pos - org, dy) < 0) {
		a += dy;
		b -= dy;
		dy = -dy;
	}
	if(dot(eye_pos - org, dz) < 0) {
		a += dz;
		b -= dz;
		dz = -dz;
	}

	int mask = 0;
	if(dot(eye_pos - b, dx) < 0)
		mask |= 1;
	if(dot(eye_pos - b, dy) < 0)
		mask |= 2;
	if(dot(eye_pos - b, dz) < 0)
		mask |= 4;
		
	int count = 6;
	vec3 c[6];
	c[0] = a + dy;
	c[1] = a + dz;
	c[2] = a + dy + dx;
	c[3] = a + dz + dx;

	// equivalent cases:
	// 0
	// 0: 000

	// 1, 2, 4:
	// 1: 001
	// 2: 010
	// 4: 100

	// 3, 5, 6:
	// 3: 011
	// 5: 101
	// 6: 110

	switch(mask) {
	case 0:
		c[1] = b - dx;
		c[3] = a + dz;

		c[4] = a + dx;
		c[5] = b - dy;
		break;
	case 1:
		c[1] = b - dz;
		c[2] = b - dx;
		c[3] = b;

		c[4] = a + dz;
		c[5] = b - dy;
		break;
	case 2:
		c[0] = b - dx;
		c[2] = b;

		c[4] = b - dz;
		c[5] = a + dx;
		break;
	case 3:
		c[0] = b - dx;
		c[2] = b;
		count = 4;
		break;
	case 4:
		c[1] = b - dx;
		c[3] = b;

		c[4] = a + dx;
		c[5] = b - dy;
		break;
	case 5:
		c[1] = b - dx;
		c[3] = b;
		count = 4;
		break;
	case 6:
		c[0] = b - dz;
		c[1] = b;
		c[2] = a + dx;
		count = 4;
		break;
	}

	vec3 ext = vec3(
		length(dx),
		length(dy),
		length(dz)
	);

	// calculate the distance to the box and use this to move the corners in front of the box
	float dist = sd_box(eye_pos - org, 0.5*ext);
	c[0] = eye_pos + dist * normalize(c[0] - eye_pos);
	c[1] = eye_pos + dist * normalize(c[1] - eye_pos);
	c[2] = eye_pos + dist * normalize(c[2] - eye_pos);
	c[3] = eye_pos + dist * normalize(c[3] - eye_pos);
	c[4] = eye_pos + dist * normalize(c[4] - eye_pos);
	c[5] = eye_pos + dist * normalize(c[5] - eye_pos);

	qTube.s.pos = (get_modelview_matrix() * vec4(qTube.s.pos, 1.0)).xyz;
	qTube.h.pos = (get_modelview_matrix() * vec4(qTube.h.pos, 1.0)).xyz;
	qTube.e.pos = (get_modelview_matrix() * vec4(qTube.e.pos, 1.0)).xyz;
	qTube_fs = qTube;

	l_offset_fs = segment_idx == 0 ? 0.0 : 0.5;

	vec4 ps[6];

	ps[0] = get_modelview_matrix() * vec4(c[0], 1.0);
	ps[1] = get_modelview_matrix() * vec4(c[1], 1.0);
	ps[2] = get_modelview_matrix() * vec4(c[2], 1.0);
	ps[3] = get_modelview_matrix() * vec4(c[3], 1.0);
	ps[4] = get_modelview_matrix() * vec4(c[4], 1.0);
	ps[5] = get_modelview_matrix() * vec4(c[5], 1.0);

	mat4 PM = get_projection_matrix();

	for(int i = 0; i < count; ++i) {
		position_fs = ps[i].xyz;
		gl_Position = PM * ps[i];
		EmitVertex();
	}
	EndPrimitive();
}

#else

vec3 intersect_plane(vec3 pn, vec3 ro, vec3 rd) {
	// the plane has its origin in (0,0,0)
	// assume that there always is an intersection
	float t = dot(-ro, pn) / dot(pn, rd);
	return ro + t * rd;
}

void emit_box_billboard(int segment_idx, QTube qTube) {
	/*=========================================
	PROBLEM:
	Billboard gets very large (fills screen) on certain view configurations.
	Probably when behind the eye position.
	=========================================*/

	mat4 M = calculate_transformation_matrix(qTube);
	vec3 p000 = (M * corners2[0]).xyz;
	vec3 p100 = (M * corners2[1]).xyz;
	vec3 p010 = (M * corners2[2]).xyz;
	vec3 p001 = (M * corners2[3]).xyz;

	vec3 dx = p100 - p000;
	vec3 dy = p010 - p000;
	vec3 dz = p001 - p000;

	vec3 p110 = p100 + dy;
	vec3 p101 = p100 + dz;
	vec3 p011 = p010 + dz;
	vec3 p111 = p110 + dz;

	vec3 aligned_up = normalize(cross(dx, view_dir));
	vec3 aligned_right = cross(view_dir, aligned_up); // no need to normalize cross product of two unit vectors
	
	vec3 ps[8];
	// The plane is defined by origin p000 and view direction as normal.
	// By subtracting p000 from the points the plane origin is effectively moved to (0,0,0).
	// Further the normalization of the directional vectors, i.e. eye_pos - p###, is not necessary,
	// since this does not influece the computation of the intersection point.
	ps[0] = intersect_plane(view_dir, p000 - p000, eye_pos - p000);
	ps[1] = intersect_plane(view_dir, p100 - p000, eye_pos - p100);
	ps[2] = intersect_plane(view_dir, p010 - p000, eye_pos - p010);
	ps[3] = intersect_plane(view_dir, p001 - p000, eye_pos - p001);

	ps[4] = intersect_plane(view_dir, p110 - p000, eye_pos - p110);
	ps[5] = intersect_plane(view_dir, p101 - p000, eye_pos - p101);
	ps[6] = intersect_plane(view_dir, p011 - p000, eye_pos - p011);
	ps[7] = intersect_plane(view_dir, p111 - p000, eye_pos - p111);

	// same as projecting ps[i] onto the line p000 + t*aligned_right; keeps the sign and only gets the length; division by squared length  of aligned_right not necessary, since aligned_right is a unit vector
	float u, min_u, max_u;
	u = dot(ps[0], aligned_right); min_u = u; max_u = u;
	u = dot(ps[1], aligned_right); min_u = min(min_u, u); max_u = max(max_u, u);
	u = dot(ps[2], aligned_right); min_u = min(min_u, u); max_u = max(max_u, u);
	u = dot(ps[3], aligned_right); min_u = min(min_u, u); max_u = max(max_u, u);
	u = dot(ps[4], aligned_right); min_u = min(min_u, u); max_u = max(max_u, u);
	u = dot(ps[5], aligned_right); min_u = min(min_u, u); max_u = max(max_u, u);
	u = dot(ps[6], aligned_right); min_u = min(min_u, u); max_u = max(max_u, u);
	u = dot(ps[7], aligned_right); min_u = min(min_u, u); max_u = max(max_u, u);

	float v, min_v, max_v;
	v = dot(ps[0], aligned_up); min_v = v; max_v = v;
	v = dot(ps[1], aligned_up); min_v = min(min_v, v); max_v = max(max_v, v);
	v = dot(ps[2], aligned_up); min_v = min(min_v, v); max_v = max(max_v, v);
	v = dot(ps[3], aligned_up); min_v = min(min_v, v); max_v = max(max_v, v);
	v = dot(ps[4], aligned_up); min_v = min(min_v, v); max_v = max(max_v, v);
	v = dot(ps[5], aligned_up); min_v = min(min_v, v); max_v = max(max_v, v);
	v = dot(ps[6], aligned_up); min_v = min(min_v, v); max_v = max(max_v, v);
	v = dot(ps[7], aligned_up); min_v = min(min_v, v); max_v = max(max_v, v);

	vec3 c[4];
	c[0] = p000 + min_u * aligned_right + min_v * aligned_up;
	c[1] = p000 + max_u * aligned_right + min_v * aligned_up;
	c[2] = p000 + min_u * aligned_right + max_v * aligned_up;
	c[3] = p000 + max_u * aligned_right + max_v * aligned_up;
	
	vec3 ext = vec3(
		length(dx),
		length(dy),
		length(dz)
	);

	float dist = sd_box(eye_pos - 0.5*(p000 + p111), 0.5*ext);
	c[0] = eye_pos + dist * normalize(c[0] - eye_pos);
	c[1] = eye_pos + dist * normalize(c[1] - eye_pos);
	c[2] = eye_pos + dist * normalize(c[2] - eye_pos);
	c[3] = eye_pos + dist * normalize(c[3] - eye_pos);

	qTube.s.pos = (get_modelview_matrix() * vec4(qTube.s.pos, 1.0)).xyz;
	qTube.h.pos = (get_modelview_matrix() * vec4(qTube.h.pos, 1.0)).xyz;
	qTube.e.pos = (get_modelview_matrix() * vec4(qTube.e.pos, 1.0)).xyz;
	qTube_fs = qTube;
	
	l_offset_fs = segment_idx == 0 ? 0.0 : 0.5;
	
	position_fs = (get_modelview_matrix() * vec4(c[0], 1.0)).xyz;
	gl_Position = get_modelview_projection_matrix() * vec4(c[0], 1.0);
	EmitVertex();
	position_fs = (get_modelview_matrix() * vec4(c[1], 1.0)).xyz;
	gl_Position = get_modelview_projection_matrix() * vec4(c[1], 1.0);
	EmitVertex();
	position_fs = (get_modelview_matrix() * vec4(c[2], 1.0)).xyz;
	gl_Position = get_modelview_projection_matrix() * vec4(c[2], 1.0);
	EmitVertex();
	position_fs = (get_modelview_matrix() * vec4(c[3], 1.0)).xyz;
	gl_Position = get_modelview_projection_matrix() * vec4(c[3], 1.0);
	EmitVertex();
	EndPrimitive();
}

#endif

void main()
{
	Tube tube;
	
	node_data_type n0 = nodes[node_ids_gs[0].x];
	
	tube.s.pos = n0.pos_rad.xyz;
	tube.s.rad = n0.pos_rad.w * radius_scale;
	tube.s.pos_tan = n0.tangent.xyz;
	tube.s.rad_tan = n0.tangent.w;

	node_data_type n1 = nodes[node_ids_gs[0].y];
	
	tube.e.pos = n1.pos_rad.xyz;
	tube.e.rad = n1.pos_rad.w * radius_scale;
	tube.e.pos_tan = n1.tangent.xyz;
	tube.e.rad_tan = n1.tangent.w;

	color0_fs = n0.color.rgb;
	color1_fs = n1.color.rgb;
	
	QTube qTube0, qTube1;
	SplitTube(tube, qTube0, qTube1);
	
	segment_id_fs = segment_id_gs[0];

#if USE_CUBIC_TANGENTS == 1
	mat4 Bk; // matrix of control points and tangents
	Bk[0] = vec4(tube.s.pos, 0.0);
	Bk[1] = vec4(tube.e.pos, 0.0);
	Bk[2] = vec4(tube.s.pos_tan, 0.0);
	Bk[3] = vec4(tube.e.pos_tan, 0.0);

	mat4 Mh; // hermite matrix
	Mh[0] = vec4( 2, -2,  1,  1);
	Mh[1] = vec4(-3,  3, -2, -1);
	Mh[2] = vec4( 0,  0,  1,  0);
	Mh[3] = vec4( 1,  0,  0,  0);
	SM_fs = Bk * Mh;
#endif

#if BOUNDING_GEOMETRY_TYPE == 0
#elif BOUNDING_GEOMETRY_TYPE == 1
	emit_rounded_cone_billboard(0, qTube0);
	emit_rounded_cone_billboard(1, qTube1);
#elif BOUNDING_GEOMETRY_TYPE == 2
	emit_exact_box_polygon(0, qTube0);
	emit_exact_box_polygon(1, qTube1);
#else
	emit_box_billboard(0, qTube0);
	emit_box_billboard(1, qTube1);
#endif
}
