#version 460
#define M_INV_PI 0.31830988618
#define ONE_OVER_THREE (1.0/3.0)

/* 0: NO_OP
   1: RASTERIZE_DEBUG
   2: RAYCAST_DEBUG
   3: RAYCAST */
#define MODE 3

/* 0: All attributes in geom->frag interface
   1: No curve attributes in geom->frag interface
   2: No color attributes in geom->frag interface
   3: Attribute-less (except segment and sub-curve ids) */
#define ATTRIB_MODE 0

#define FLT_EPS 1.19209290e-07
#define POS_INF 3e+37
#define NEG_INF -3e+37
#define N0 3
#define N1 5

//***** begin interface of view.glsl ***********************************
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_inverse_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
//***** end interface of view.glsl ***********************************

struct TubeNode {
	vec3 pos;
	float rad;

	vec3 pos_tan;
	float rad_tan;
};

struct Tube {
	TubeNode s;
	TubeNode e;
};

struct QTubeNode {
	vec3 pos;
	float rad;
};

struct QTube {
	QTubeNode s;
	QTubeNode h;
	QTubeNode e;
};

struct Hit {
	float l;
	float t;
	vec3 normal;
	vec3 sp;
	bool cap;
};

uniform float radius_scale;
uniform vec3 cyclopic_eye;
uniform vec4 viewport;
uniform float max_t;
uniform float cap_clip_distance;

struct node_data_type {
	vec4 pos_rad;
	vec4 color;
	vec4 tangent;
	vec4 frame_normal_t; // frame normal in .xyz, timestamp in .w
};

// node attribute buffer
layout(std430, binding = 0) readonly buffer data_buffer {
    node_data_type nodes[];
};

// arclen approximations SBO
layout (std430, binding = 1) readonly buffer arclen_buffer { 
  mat4 b[]; // 4 cubic beziers packed into colums of mat4
};

// node index pair buffer
layout(std430, binding = 2) readonly buffer nid_buffer {
    uvec2 node_ids[];
};

in vec3 position_fs;
in vec3 normal_fs;
in vec2 texcoords_fs;
in flat float l_offset_fs;
#if !(ATTRIB_MODE & 2)
	in flat uint color0_fs;
	in flat uint color1_fs;
#endif
#if !(ATTRIB_MODE & 1)
	in flat QTube qTube_fs;
#endif
in flat int segment_id_fs;
in flat mat4 SM_fs; // spline matrix

layout (location = 0) out vec4 frag_albedo;
layout (location = 1) out vec3 frag_position;
layout (location = 2) out vec3 frag_normal;
layout (location = 3) out vec3 frag_tangent;

#define DEF_SplitCurve0(T)						\
void SplitCurve0(T v0, T d0, T v1, T d1,		\
	out T v00_out, out T h0_out, out T v10_out)	\
{												\
	v00_out = v0;								\
	h0_out = v0 + d0 * 0.2667/*ONE_OVER_THREE*/;	\
	const T h1 = v1 - d1 * 0.2667/*ONE_OVER_THREE*/;	\
	v10_out = (h0_out + h1) * 0.5;				\
}

#define DEF_SplitCurve1(T)						\
void SplitCurve1(T v0, T d0, T v1, T d1,		\
	out T v01_out, out T h1_out, out T v11_out)	\
{												\
	const T h0 = v0 + d0 * 0.2667/*ONE_OVER_THREE*/;	\
	h1_out = v1 - d1 * 0.2667/*ONE_OVER_THREE*/;	\
	v01_out = (h0 + h1_out) * 0.5;				\
	v11_out = v1;								\
}

DEF_SplitCurve0(float)
DEF_SplitCurve0(vec3)
DEF_SplitCurve1(float)
DEF_SplitCurve1(vec3)

#define SPLIT_CURVE0(TUBE, MEM_V, MEM_D, QTUBE)				\
SplitCurve0(												\
	TUBE.s.MEM_V, TUBE.s.MEM_D, TUBE.e.MEM_V, TUBE.e.MEM_D,	\
	QTUBE.s.MEM_V, QTUBE.h.MEM_V, QTUBE.e.MEM_V				\
)
#define SPLIT_CURVE1(TUBE, MEM_V, MEM_D, QTUBE)				\
SplitCurve1(												\
	TUBE.s.MEM_V, TUBE.s.MEM_D, TUBE.e.MEM_V, TUBE.e.MEM_D,	\
	QTUBE.s.MEM_V, QTUBE.h.MEM_V, QTUBE.e.MEM_V				\
)

void SplitTube0(Tube tube, out QTube qTube)
{
	SPLIT_CURVE0(tube, pos, pos_tan, qTube);
	SPLIT_CURVE0(tube, rad, rad_tan, qTube);
}
void SplitTube1(Tube tube, out QTube qTube)
{
	SPLIT_CURVE1(tube, pos, pos_tan, qTube);
	SPLIT_CURVE1(tube, rad, rad_tan, qTube);
}

float eval_cubic_bezier(float t, vec4 cp) {
	const vec4 monomials = vec4(1.0, t, t*t, t*t*t);
	const mat4 Mc = mat4(
		1, -3,  3, -1,
		0,  3, -6,  3,
		0,  0,  3, -3,
		0,  0,  0,  1
	);
	return dot(monomials, Mc * cp);
}

// arclength evaluation
// length scale should be set to 1/radius with curvature correction on
float alen (float t)
{
	const float t4 = t+t+t+t;
	const int seg = max(int(min(t4, 3)), 0);
	const float t_inner = t4 - seg;
	return eval_cubic_bezier(t_inner, b[segment_id_fs][seg]);
}

vec3 eval_quadratic_bezier_tangent(QTube qtube, float t)
{
	mat3 Bk; // control point matrix
	Bk[0] = qtube.s.pos;
	Bk[1] = qtube.h.pos;
	Bk[2] = qtube.e.pos;
	
	mat3 Mb; // quadratic bezier matrix
	Mb[0] = vec3( 1,  0,  0);
	Mb[1] = vec3(-2,  2,  0);
	Mb[2] = vec3( 1, -2,  1);

	mat3 M = Bk * Mb;
	
	// quadratic bezier (1, t, t^2)
	// 1st derivative (0, 1, 2t)
	return M * vec3(0.0, 1, 2.0*t);
}

vec3 eval_cubic_hermite_tangent(float t) {
	vec4 tvec = vec4(3.0*t*t, 2.0*t, 1.0, 0.0);
	return (SM_fs * tvec).xyz;
}

void main()
{
	////
	// Retrieve segment curve data

	#if ATTRIB_MODE > 0
		const node_data_type n0 = nodes[node_ids[segment_id_fs].x];
		const node_data_type n1 = nodes[node_ids[segment_id_fs].y];
		const float n0_t=n0.frame_normal_t.w, n1_t=n1.frame_normal_t.w;
		vec3 color0, color1;

		#if ATTRIB_MODE & 1
			// compile hermite tube info
			Tube tube;
			tube.s.pos = n0.pos_rad.xyz;
			tube.s.rad = n0.pos_rad.w * radius_scale;
			tube.s.pos_tan = n0.tangent.xyz;
			tube.s.rad_tan = n0.tangent.w;

			tube.e.pos = n1.pos_rad.xyz;
			tube.e.rad = n1.pos_rad.w * radius_scale;
			tube.e.pos_tan = n1.tangent.xyz;
			tube.e.rad_tan = n1.tangent.w;

			// prepare for quadratic split further down
			const mat4 MV = get_modelview_matrix();
			QTube qtube;
		#else
			const QTube qtube = qTube_fs;
		#endif
		if (l_offset_fs == 0) // Select "our" quadratic sub segment
		{
		#if ATTRIB_MODE & 1
			// perform quadratic split
			SplitTube0(tube, qtube);
			qtube.s.pos = (MV * vec4(qtube.s.pos, 1.0)).xyz;
			qtube.h.pos = (MV * vec4(qtube.h.pos, 1.0)).xyz;
			qtube.e.pos = (MV * vec4(qtube.e.pos, 1.0)).xyz;
			qtube.s.rad = qtube.s.rad;
			qtube.h.rad = qtube.h.rad;
			qtube.e.rad = qtube.e.rad;
		#endif
		}
		else
		{
		#if ATTRIB_MODE & 1
			// perform quadratic split
			SplitTube1(tube, qtube);
			qtube.s.pos = (MV * vec4(qtube.s.pos, 1.0)).xyz;
			qtube.h.pos = (MV * vec4(qtube.h.pos, 1.0)).xyz;
			qtube.e.pos = (MV * vec4(qtube.e.pos, 1.0)).xyz;
			qtube.s.rad = qtube.s.rad;
			qtube.h.rad = qtube.h.rad;
			qtube.e.rad = qtube.e.rad;
		#endif
		}
		#if ATTRIB_MODE & 2
			// fetch color from SBO
			color0 = n0.color.rgb;
			color1 = n1.color.rgb;
		#endif
	#else
		const QTube qtube = qTube_fs;
		const float n0_t = nodes[node_ids[segment_id_fs].x].t.x,
		            n1_t = nodes[node_ids[segment_id_fs].y].t.x;
	#endif

#if MODE == 0
	discard;
	return;
#elif MODE == 1
	frag_albedo = vec4(uintBitsToFloat(0xFF0000FF), 0.0, 0.0, intBitsToFloat(0));
	frag_position = vec3(0.0, 0.0, 1.0);
	frag_normal = vec3(0.0, 0.0, 1.0);
	frag_tangent = vec3(1.0, 0.0, 0.0);
	return;
#else
	vec3 hit_pos_eye = position_fs;
	float spline_t = texcoords_fs.x;
	// determine color - since we ignore the tangents, interpolation is just linear
	const vec4 col = spline_t >= max_t ? vec4(0.75, 0.75, 0.75, 1) :
	#if ATTRIB_MODE & 2
		vec4(mix(color0, color1, spline_t), 1.0);
	#else
		vec4(mix(unpackUnorm4x8(color0_fs).rgb, unpackUnorm4x8(color1_fs).rgb, spline_t), 1.0);
	#endif

	// tangent is given in object space
	vec3 tangent = eval_cubic_hermite_tangent(spline_t);
	// transform the tangent from object space to eye space
	tangent = normalize(get_normal_matrix() * tangent);
	
	float v = texcoords_fs.y;

	frag_albedo = vec4(uintBitsToFloat(packUnorm4x8(col)), alen(spline_t), v, intBitsToFloat(segment_id_fs));
	frag_position = vec3(hit_pos_eye);
	frag_normal = normal_fs;
	frag_tangent = tangent;
#endif
}
