#version 430
#define M_PI 3.14159265359

#define DEBUG_SEGMENTS 0

#define GRID_MODE 1
#define ENABLE_FUZZY_GRID 0
#define GRID_NORMAL_SETTINGS 0

#define CONSTANT_FLOAT_UNIFORM_COUNT 0
#define CONSTANT_COLOR_UNIFORM_COUNT 0
#define MAPPING_PARAMETER_UNIFORM_COUNT 0
#define L0_MAPPED_ATTRIB_COUNT 0
#define L0_GLYPH_DEFINITION
#define L1_MAPPED_ATTRIB_COUNT 0
#define L1_GLYPH_DEFINITION
#define L2_MAPPED_ATTRIB_COUNT 0
#define L2_GLYPH_DEFINITION
#define L3_MAPPED_ATTRIB_COUNT 0
#define L3_GLYPH_DEFINITION

//***** begin interface of view.glsl ***********************************
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
//***** end interface of view.glsl ***********************************

////***** begin interface of surface.glsl ***********************************
vec4 compute_reflected_appearance(vec3 position_eye, vec3 normal_eye, vec4 color, int side);
////***** end interface of surface.glsl ***********************************

layout (binding = 0) uniform sampler2D albedo_tex;
layout (binding = 1) uniform sampler2D position_tex;
layout (binding = 2) uniform sampler2D normal_tex;
layout (binding = 3) uniform sampler2D tangent_tex;
layout (binding = 4) uniform sampler2D info_tex; // TODO: is this needed?
layout (binding = 5) uniform sampler2D depth_tex;
layout (binding = 6) uniform sampler3D density_tex;
layout (binding = 7) uniform sampler2D color_maps_tex;

// basic rendering parameters
//uniform vec3 background_color;
uniform bool use_gamma = false;

// ambient occlusion parameters
uniform struct {
	bool enable;
	float sample_offset;
	float sample_distance;
	float strength_scale;
	vec3 tex_offset;
	vec3 tex_scaling;
	vec3 texcoord_scaling;
	float texel_size;
	float cone_angle_factor;
	vec3 sample_directions[3];
} ambient_occlusion;

// grid parameters
struct grid_parameters {
	vec2 scaling;
	float thickness;
	float blend_factor;
};
uniform vec4 grid_color;
uniform float normal_mapping_scale = 1.0;
uniform grid_parameters grids[2];

// attribute mapping parameters
#if CONSTANT_FLOAT_UNIFORM_COUNT > 0
uniform float glyph_cf_param[CONSTANT_FLOAT_UNIFORM_COUNT];
#endif
#if CONSTANT_COLOR_UNIFORM_COUNT > 0
uniform vec3 glyph_cc_param[CONSTANT_COLOR_UNIFORM_COUNT];
#endif

#if MAPPING_PARAMETER_UNIFORM_COUNT > 0
uniform vec4 glyph_m_param[MAPPING_PARAMETER_UNIFORM_COUNT];
#endif

uniform struct {
	bool use_curvature_correction;
	float length_scale; // only for testing purposes
	float antialias_radius;
} general_settings;

in vec2 texcoord_fs;

out vec4 frag_color;

struct irange {
	int i0, n;
};

// attribute and range buffers for each glyph layer
// free attributes ssbos
// free attributes per-segment index ranges
#define DEF_GLYPH_DESC_AND_BUFFERS(I, N, B0, B1) \
struct glyph_desc##I { \
	float s; \
	uint debug_info; \
	float v[N]; \
}; \
layout (std430, binding=B0) readonly buffer attribs_buffer##I { \
	glyph_desc##I glyphs##I[]; \
}; \
layout (std430, binding=B1) readonly buffer ranges_buffer##I { \
	irange ranges##I[]; \
}; \

struct closest_glyphs_info {
	int prev, next, id;
	float dp, dn, d;
};

#define DEF_CLOSEST_SAMPLES(I, ranges, glyphs) \
bool get_closest_samples##I(in int segid, in float s, out closest_glyphs_info closest) { \
	const irange segment = ranges[segid]; \
	if (segment.n > 0) { \
		irange rng = segment; \
		while (rng.n > 1) { \
			const int mid_n = rng.n/2, mid = rng.i0+mid_n; \
			if (glyphs[mid].s > s) rng.n = mid_n; \
			else { rng.i0 = rng.i0 + mid_n; rng.n  = rng.n  - mid_n; } \
		} \
		closest.prev = rng.i0; \
		closest.next = rng.i0 < segment.i0+segment.n-1 ? rng.i0+1 : rng.i0; \
		closest.dp = s-glyphs[rng.i0].s; \
		closest.dn = glyphs[closest.next].s-s; \
		const bool n_lt_p = closest.dn < closest.dp; \
		closest.id = n_lt_p ? closest.next : closest.prev; \
		closest.d  = n_lt_p ? closest.dn : closest.dp; \
		return true; \
	} \
	return false; \
}

#if L0_MAPPED_ATTRIB_COUNT > 0
DEF_GLYPH_DESC_AND_BUFFERS(0, L0_MAPPED_ATTRIB_COUNT, 0, 1)
DEF_CLOSEST_SAMPLES(0, ranges0, glyphs0)
#endif

#if L1_MAPPED_ATTRIB_COUNT > 0
DEF_GLYPH_DESC_AND_BUFFERS(1, L1_MAPPED_ATTRIB_COUNT, 2, 3)
DEF_CLOSEST_SAMPLES(1, ranges1, glyphs1)
#endif

#if L2_MAPPED_ATTRIB_COUNT > 0
DEF_GLYPH_DESC_AND_BUFFERS(2, L2_MAPPED_ATTRIB_COUNT, 4, 5)
DEF_CLOSEST_SAMPLES(2, ranges2, glyphs2)
#endif

#if L3_MAPPED_ATTRIB_COUNT > 0
DEF_GLYPH_DESC_AND_BUFFERS(3, L3_MAPPED_ATTRIB_COUNT, 6, 7)
DEF_CLOSEST_SAMPLES(3, ranges3, glyphs3)
#endif

/*bool get_current_glyph(out glyph_desc glyph, in int seg_id, inout vec2 uv) {
	closest_glyphs_info closest;

	if (get_closest_samples(closest, seg_id, uv.s)) {
		glyph = glyphs[closest.id];

		uv = vec2(
			(closest.dp <= closest.dn ? closest.dp : -closest.dn)
			* general_settings.length_scale, // <-- ToDo: replace with automatic uv re-projection method
			uv.t
		);

		return true;
	}

	return false;
}*/

float compute_ambient_occlusion_factor(in vec3 pos_eye, in vec3 normal_eye) {
	vec3 pos = (get_inverse_modelview_matrix() * vec4(pos_eye, 1.0)).xyz;
	vec3 normal = normalize(get_inverse_normal_matrix() * normal_eye);

	// do voxel cone tracing to determine occlusion of ambient light
	float ao = 0.0;

	mat3 R;
	R[1] = normal;
	R[0] = cross(R[1], normalize(pos));
	R[2] = cross(R[0], R[1]);

	for(int i = 0; i < 3; ++i) {
		vec3 sd = R * ambient_occlusion.sample_directions[i];

		float sample_distance = ambient_occlusion.sample_offset + 0.001;
		vec3 normalized_pos = (pos - ambient_occlusion.tex_offset) * ambient_occlusion.tex_scaling;
		float lod_texel_size = 0.0f;
			
		float illumination = 1.0;

		do {
			// get cone base radius at current distance and then the according mipmap sample level
			float cone_radius = sample_distance * ambient_occlusion.cone_angle_factor;
			float sample_level = clamp(log2(cone_radius / ambient_occlusion.texel_size), 0.0, 7.0);

			lod_texel_size = pow(2.0, sample_level) * ambient_occlusion.texel_size;

			vec3 sample_pos = normalized_pos + sample_distance * sd * ambient_occlusion.texcoord_scaling;
			float density = textureLod(density_tex, sample_pos, sample_level).r;
			// apply the compositing function
			illumination *= 1.0 - density * illumination;

			// get the next sample distance and position
			sample_distance += cone_radius;
		} while(sample_distance < ambient_occlusion.sample_distance - lod_texel_size && illumination > 0.02);

		ao += (1.0 - illumination);
	}

	return 1.0 - clamp(ambient_occlusion.strength_scale * ao / 3.0, 0.0, 1.0);
}

// remap value v from range [r.x,r.y] to [r.z,r.w]
float remap(float v, vec4 r) {
	float t = 0.0;
	if(abs(r.x - r.y) > 0.00001)
		t = (v - r.x) / (r.y - r.x);
	return mix(r.z, r.w, t);
}

// clamp value v to range [r.x,r.y] and remap to [r.z,r.w]
float clamp_remap(float v, vec4 r) {
	v = clamp(v, r.x, r.y);
	float t = 0.0;
	if(abs(r.x - r.y) > 0.00001)
		t = (v - r.x) / (r.y - r.x);
	return mix(r.z, r.w, t);
}

// clamp value v to range [r.x,r.y] and remap to [0,1]
float clamp_remap01(float v, vec4 r) {
	v = clamp(v, r.x, r.y);
	float t = 0.0;
	if(abs(r.x - r.y) > 0.00001)
		t = (v - r.x) / (r.y - r.x);
	return t;
}

// clamp value v to range [r.x,r.y] and remap to [-1,1]
float clamp_remap11(float v, vec4 r) {
	v = clamp(v, r.x, r.y);
	float t = 0.0;
	if(abs(r.x - r.y) > 0.00001)
		t = (v - r.x) / (r.y - r.x);
	return 2.0*t - 1.0;
}

//vec3 map_to_color(float v, float map_idx_coord) {
vec3 map_to_color(float v, int color_map_idx) {
	vec2 ts = textureSize(color_maps_tex, 0);
	float half_step = 0.5 * (1.0 / ts.y); 
	float map_coord = float(color_map_idx) / ts.y + half_step;
	return texture(color_maps_tex, vec2(v, map_coord)).rgb;
}

// return a rotation matrix given angle in radians
mat2 rot_mat(float a) {
	float as = sin(a);
	float ac = cos(a);
	return mat2(ac, as, -as, ac);
}

// rotate a 2d point by the given angle in radians
vec2 rotate(in vec2 p, in float a) {
	const float quarter_turn = 1.57079632679; // additional rotation of 90 degrees, so an angle of 0 degrees points the glyph into the direction of the segment
	a += quarter_turn;
	return rot_mat(a) * p;
}

// SDF operations
float op_union(float d0, float d1) {
  return min(d0, d1);
}

float op_subtract(float d0, float d1) {
	return max(-d0, d1);
}

float op_onion(float d, float r) {
  return abs(d) - r;
}

float dot2(in vec2 v) { return dot(v, v); }

// most SDFs from https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm

// dummy that returns a negative distance as if we are always in the interior of tha shape
float sd_color(in vec2 p) {
    return -1.0;
}

// r is the radius of the circle
float sd_circle(in vec2 p, in float r) {
    return length(p) - r;
}

// a is the width/length of the rectangle
// b is the height of the rectangle
float sd_rectangle(in vec2 p, in float a, in float b) {
    vec2 d = abs(p)-0.5*vec2(a,b);
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

// r is the radius of the circle wedge
// a is the aperture angle in radians
float sd_wedge(in vec2 p, in float r, in float a) {
	vec2 sca = vec2(sin(a), cos(a));

    p.x = abs(p.x);
    float l = length(p) - r;
    float m = length(p-sca*clamp(dot(p,sca),0.0,r));
    return max(l,m*sign(sca.y*p.x-sca.x*p.y));
}

// ra is the radius of the arc
// rb is the radius of the stroke
// a is the aperture angle in radians
float sd_arc_flat(in vec2 p, in float ra, in float rb, in float a) {
	float d0 = sd_wedge(p, ra + rb, a);
	float d1 = sd_circle(p, ra - rb);
	return op_subtract(d1, d0);
}

// ra is the radius of the arc
// rb is the radius of the stroke
// a is the aperture angle in radians
float sd_arc_rounded(in vec2 p, in float ra, in float rb, in float a) {
	vec2 sca = vec2(sin(a), cos(a));
    p.x = abs(p.x);
    float k = (sca.y*p.x>sca.x*p.y) ? dot(p,sca) : length(p);
    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;
}

/*
	Currently the triangle is centered and rotates around the tip. To center it to the middle of the height use:
	sd = sd_triangle_isosceles(
		rotate(glyphuv, radians(current_glyph.angle1)) - vec2(0.0, current_glyph.radius1),
		vec2(current_glyph.radius0, -2.0*current_glyph.radius1)
	);
*/
// bw is the base width of the triangle
// h is the height of the triangle
float sd_triangle_isosceles(in vec2 p, in float bw, in float h) {
	// in the default configuration the origin is at the tip of the two equal-length sides

	// flip so default orientation is along trajectory direction
	h = -h;

	// move orign to base side of triangle
	// p += h;
	// or...
	// move origin to center of triangle
	p.y += 0.5*h;

	vec2 q = vec2(0.5*bw, h);
    p.x = abs(p.x);
    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );
    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );
    float s = -sign( q.y );
    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),
                  vec2( dot(b,b), s*(p.y-q.y) ));
    return -sqrt(d.x)*sign(d.y);
}

// r1 is the base radius
// r2 is the tip radius0
// h is the height/length of the capsule
// alternative name: uneven_capsule
float sd_drop(vec2 p, float r1, float r2, float h) {
    p.x = abs(p.x);
    float b = (r1 - r2) / h;
    float a = sqrt(1.0 - b*b);
    float k = dot(p, vec2(-b, a));
    if(k < 0.0)
		return length(p) - r1;
    if(k > a*h)
		return length(p - vec2(0.0, h)) - r2;
    return dot(p, vec2(a, b)) - r1;
}

// intersection of 4 circles with unit radius
float sd_rounded_cross(in vec2 p, in float r) {
    p = abs(p);
    return
		(p.x < r && p.y < r) ? 
		r - sqrt(dot2(p - vec2(r))) :     // circular arc
		sqrt(min(dot2(p - vec2(0.0,r)),   // top corner
                 dot2(p - vec2(r,0.0)))); // right corner
}

// b is the size of the cross (total width/diameter)
// r is distance radius offset
float sd_cross(in vec2 p, in vec2 b, float r) {
    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;
    b *= 0.5;
	vec2  q = p - b;
    float k = max(q.y,q.x);
    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);
    float d = length(max(w,0.0));
    return ((k>0.0)?d:-d) + r;
}

// s is the size of the blob (total width/diameter)
// v defines the shape
// must be in [-1,1]
float sd_sign_blob(in vec2 p, in float s, in float v) {
	// first form
	// -1 is sharp pointy cross
	//  0 is circle
	// +1 is square
	//float d_circle = sd_circle(p, 0.5641896*r);
	//return v < 0.0 ?
	//	mix(sd_rounded_cross(p, 1.079328*r), d_circle, v + 1.0) :
	//	mix(d_circle, sd_rectangle(p, r, r), v);

	// second form
	// -1 is sharp pointy cross
	//  0 is diamond
	// +1 is circle
	//float d_cross = sd_rounded_cross(p, 1.079328*r);
	//float d_circle = sd_circle(p, 0.5641896*r);
	//return mix(d_cross, d_circle, 0.5*v + 0.5);

	// third form
	// -1 is minus sign
	//  0 is circle
	// +1 is plus sign
	float d_circle = sd_circle(p, 0.25*s);
	return v < 0.0 ?
		mix(sd_rectangle(p, s, 0.2*s), d_circle, v + 1.0) :
		mix(d_circle, sd_cross(p, vec2(s, 0.2*s), 0.0), v);
}

float sd_segment(in vec2 p, in vec2 a, in vec2 b) {
    vec2 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}

#define DEF_SD_POLYGON(I, N) \
float sd_polygon##I(in vec2 p, in vec2[N] v) { \
    float d = dot(p-v[0],p-v[0]); \
    float s = 1.0; \
    for(int i = 0, j = N - 1; i < N; j = i, ++i) { \
        vec2 e = v[j] - v[i]; \
        vec2 w =    p - v[i]; \
        vec2 b = w - e * clamp(dot(w, e) / dot(e, e), 0.0, 1.0); \
        d = min(d, dot(b, b)); \
        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x); \
        if(all(c) || all(not(c))) s *= -1.0; \
    } \
    return s * sqrt(d); \
}

#define DEF_SD_STAR(I, N) \
vec2 sd_star##I(vec2 p, float r, in glyph_desc##I gd, in int mapping_base_idx) { \
	vec2 org = vec2(0.0); \
	float d_axes = 1e20; \
	float d_poly = 1e20; \
	float thickness = 0.01; \
	vec2 ps[N]; \
	\
	for(int i = 0; i < N; ++i) { \
		float v = clamp_remap(gd.v[i], glyph_m_param[mapping_base_idx + i]); \
		float angle = 2.0*M_PI * (i / float(N)) + M_PI; \
		mat2 R = rot_mat(angle); \
		vec2 end = R * vec2(0.0, r); \
		vec2 pp = R * vec2(0.0, r*v); \
		ps[i] = pp; \
		d_axes = op_union(d_axes, sd_segment(p, org, pp) - thickness); \
	} \
	d_poly = sd_polygon##I(p, ps); \
	return vec2(d_axes, d_poly); \
}

#define DEF_SPLAT_STAR(I, N) \
vec4 splat_star##I(in glyph_desc##I gd, in vec2 p, in int float_base_idx, in int color_base_idx, in int mapping_base_idx) { \
	vec2 dist = sd_star##I(p, glyph_cf_param[float_base_idx], gd, mapping_base_idx); \
	float alpha_fac = 1.0; \
	\
	if((gd.debug_info & 0x1000) == 0) { \
		alpha_fac = 0.5; \
		dist.y = op_onion(dist.y + 0.05, 0.05); \
	} \
	vec3 dist3 = vec3(dist, op_onion(dist.y + 0.01, 0.01)); \
	\
	const vec3 antialias_width = general_settings.antialias_radius*fwidth(dist3); \
	vec3 alpha = 1.0 - smoothstep(-antialias_width, antialias_width, dist3); \
	\
	float theta = atan(-p.x, p.y) + M_PI; \
	theta /=  2.0*M_PI; \
	float omega = N * theta; \
	int ci0 = int(omega); \
	omega = fract(omega); \
	int ci1 = (ci0 + 1)%N; \
	\
	float limit = mix(0.01, 0.5, glyph_cf_param[float_base_idx + 2]); \
	float t = smoothstep(0.5 - limit, 0.5 + limit, omega); \
	vec3 col = mix(glyph_cc_param[color_base_idx + ci0 + 1], glyph_cc_param[color_base_idx + ci1 + 1], t); \
	\
	if(glyph_cf_param[float_base_idx + 1] < 0.5) { \
		col = mix(col, glyph_cc_param[color_base_idx], alpha.x); \
	} else { \
		col = mix(glyph_cc_param[color_base_idx], col, alpha.x); \
	} \
	return vec4(col, alpha_fac * max(alpha.x, max((1.0 - glyph_cf_param[float_base_idx + 3])*alpha.y, alpha.z))); \
}

#if L0_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_FLOAT_UNIFORM_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
DEF_SD_POLYGON(0, L0_MAPPED_ATTRIB_COUNT);
DEF_SD_STAR(0, L0_MAPPED_ATTRIB_COUNT);
DEF_SPLAT_STAR(0, L0_MAPPED_ATTRIB_COUNT);
#endif

#if L1_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_FLOAT_UNIFORM_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
DEF_SD_POLYGON(1, L1_MAPPED_ATTRIB_COUNT);
DEF_SD_STAR(1, L1_MAPPED_ATTRIB_COUNT);
DEF_SPLAT_STAR(1, L1_MAPPED_ATTRIB_COUNT);
#endif

#if L2_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_FLOAT_UNIFORM_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
DEF_SD_POLYGON(2, L2_MAPPED_ATTRIB_COUNT);
DEF_SD_STAR(2, L2_MAPPED_ATTRIB_COUNT);
DEF_SPLAT_STAR(2, L2_MAPPED_ATTRIB_COUNT);
#endif

#if L3_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_FLOAT_UNIFORM_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
DEF_SD_POLYGON(3, L3_MAPPED_ATTRIB_COUNT);
DEF_SD_STAR(3, L3_MAPPED_ATTRIB_COUNT);
DEF_SPLAT_STAR(3, L3_MAPPED_ATTRIB_COUNT);
#endif

// map_to_color(clamp_remap01(gd.v[0], glyph_m_param[mapping_base_idx]), color_map_idx);

#define DEF_SPLAT_COLOR(I) \
vec4 splat_color##I(in glyph_desc##I gd, in glyph_desc##I gd_prev, in glyph_desc##I gd_next, in vec2 p, in int color_map_idx, in int float_base_idx, in int color_base_idx, in int mapping_base_idx) { \
	float v0 = clamp_remap01(gd.v[0], glyph_m_param[mapping_base_idx]); \
	float v1; \
	float t; \
	if(p.x < gd.s) { \
		t = 1.0 - clamp_remap01(p.x, vec4(gd_prev.s, gd.s, 0.0, 0.0)); \
		v1 = clamp_remap01(gd_prev.v[0], glyph_m_param[mapping_base_idx]); \
	} else { \
		t = clamp_remap01(p.x, vec4(gd.s, gd_next.s, 0.0, 0.0)); \
		v1 = clamp_remap01(gd_next.v[0], glyph_m_param[mapping_base_idx]); \
	} \
	t = glyph_cf_param[float_base_idx] < 0.5 ? step(0.5, t) : t; \
	vec3 color; \
	if(glyph_cf_param[float_base_idx + 1] < 0.5) { \
		vec3 c0 = map_to_color(v0, color_map_idx); \
		vec3 c1 = map_to_color(v1, color_map_idx); \
		color = mix(c0, c1, t); \
	} else { \
		v0 = mix(v0, v1, t); \
		color = map_to_color(v0, color_map_idx); \
	} \
	return vec4(color, 1.0); \
}

#if L0_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_FLOAT_UNIFORM_COUNT > 0
DEF_SPLAT_COLOR(0)
#endif

#if L1_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_FLOAT_UNIFORM_COUNT > 0
DEF_SPLAT_COLOR(1)
#endif

#if L2_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_FLOAT_UNIFORM_COUNT > 0
DEF_SPLAT_COLOR(2)
#endif

#if L3_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_FLOAT_UNIFORM_COUNT > 0
DEF_SPLAT_COLOR(3)
#endif

#define DEF_SPLAT_VIOLIN(I, N) \
vec4 splat_violin##I(in glyph_desc##I gd, in glyph_desc##I gd_prev, in glyph_desc##I gd_next, in vec2 p, in int float_base_idx, in int color_base_idx, in int mapping_base_idx) { \
	int idx = int(float(N) * (0.5*p.y + 0.5)); \
	idx = min(idx, N - 1); \
	\
	float st = 2.0/float(N); \
	float offset = -1.0 + st*float(idx) + 0.5*st; \
	p.y += -offset; \
	p.y *= float(N); \
	p.y = abs(p.y); \
	\
	vec4 mapping_ranges = glyph_m_param[mapping_base_idx + idx]; \
	float s0; \
	float s1 = gd.s; \
	float v0; \
	float v1 = clamp_remap(gd.v[idx], mapping_ranges); \
	float t; \
	if(p.x < gd.s) { \
		s0 = gd_prev.s; \
		v0 = clamp_remap(gd_prev.v[idx], mapping_ranges); \
		t = clamp_remap01(p.x, vec4(gd_prev.s, gd.s, 0.0, 0.0)); \
	} else { \
		s0 = gd_next.s; \
		v0 = clamp_remap(gd_next.v[idx], mapping_ranges); \
		t = 1.0 - clamp_remap01(p.x, vec4(gd.s, gd_next.s, 0.0, 0.0)); \
	} \
	float vv = mix(v0, v1, t); \
	float dist = p.y - vv; \
	\
	const float antialias_width = general_settings.antialias_radius*fwidth(dist); \
	float alpha = 1.0 - smoothstep(-antialias_width, antialias_width, dist); \
	\
	return vec4(glyph_cc_param[color_base_idx + idx], alpha); \
}

#if L0_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
DEF_SPLAT_VIOLIN(0, L0_MAPPED_ATTRIB_COUNT);
#endif

#if L1_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
DEF_SPLAT_VIOLIN(1, L1_MAPPED_ATTRIB_COUNT);
#endif

#if L2_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
DEF_SPLAT_VIOLIN(2, L2_MAPPED_ATTRIB_COUNT);
#endif

#if L3_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
DEF_SPLAT_VIOLIN(3, L3_MAPPED_ATTRIB_COUNT);
#endif

float grid_texture_fuzzy(in vec2 p, in float n) {
	// coordinates
	vec2 s = fract(p + 0.5*n);
	vec2 t = clamp(s / n, 0.0, 1.0);

	vec2 i = sin(M_PI*t);
	return max(i.x, i.y);
}

float grid_texture_aa(in vec2 p, in float n, float aa_strength) {
	// pre-filter AA preparations
	const float na = n*0.5, nb = 1.0-n*0.5;
	const vec2 p_frac = fract(p), w = aa_strength*fwidth(p);

	// coordinates
	const vec2 i = vec2(1) - smoothstep(na-w, na+w, p_frac) + smoothstep(nb-w, nb+w, p_frac);

	//pattern (from https://www.shadertoy.com/view/XtBfzz)
	return 1.0 - (1.0-i.s)*(1.0-i.t);	// grid
	//return 1.0-i.s*i.t;				// squares
	//return 1.0-i.s-i.t+2.0*i.s*i.t;	// checker
}

float grid_texture(in vec2 p, in float n) {
#if ENABLE_FUZZY_GRID == 1
	return grid_texture_fuzzy(p, n);
#else
	return grid_texture_aa(p, n , 1);
#endif
}

float aa_texture(in vec2 p, in float n, float aa_strength) {
	// pre-filter AA preparations
	const float na = n*0.5, nb = 1.0-n*0.5;
	const vec2 p_frac = fract(p), w = 2*aa_strength*fwidth(p);

	// coordinates
	const vec2 i = vec2(1) - smoothstep(na-w, vec2(na), p_frac) + smoothstep(vec2(nb), nb+w, p_frac);

	//pattern (from https://www.shadertoy.com/view/XtBfzz)
	return 1.0 - (1.0-i.s)*(1.0-i.t);	// grid
	//return 1.0-i.s*i.t;				// squares
	//return 1.0-i.s-i.t+2.0*i.s*i.t;	// checker
}

vec3 grid_normal(in vec2 p, in float n) {

	// coordinates
	vec2 s = fract(p + 0.5*n);
	vec2 t = clamp(s / n, 0.0, 1.0);

#if (GRID_NORMAL_SETTINGS & 3) == 0
#if GRID_NORMAL_SETTINGS & 8
	vec2 xy = sin(0.5*M_PI*sin(2.0*M_PI*t));
	vec2 z = 0.5*sin(0.5*M_PI*cos(2.0*M_PI*t)) + 0.5;
#else
	vec2 xy = sin(2.0*M_PI*t);
	vec2 z = 0.5*cos(2.0*M_PI*t) + 0.5;
#endif
	vec3 normal = normalize(vec3(-xy.x, xy.y, max(z.x, z.y)));
#elif (GRID_NORMAL_SETTINGS & 3) == 1
	vec2 i = sin(M_PI*t);
	vec2 xy = sin(2.0*M_PI*t);

	vec3 normal = vec3(0.0, 0.0, 0.0);
#if GRID_NORMAL_SETTINGS & 8
	vec3 n0 = vec3(-xy.x, 0.0, 0.0);
	vec3 n1 = vec3(0.0, xy.y, 0.0);

	float d = abs(i.x - i.y);
	float sum = i.x + i.y;

	if(i.x > i.y) normal = n0;
	else normal = n1;

	if(d < 0.2) {
		float a = 1.0 - d / 0.2;
		vec3 n2 = 0.5*(n0 + n1);
		normal = mix(normal, n2, a);
	}
	float v = normal.x*normal.x + normal.y*normal.y;
	normal.z = (v >= 0.99999) ? 0.0 : sqrt(1.0 - v);
#else
	if(i.x > i.y) normal.x = -xy.x;
	else normal.y = xy.y;

	float v = normal.x + normal.y;
	v *= v;
	normal.z = (v >= 0.99999) ? 0.0 : sqrt(1.0 - v);
#endif

#elif (GRID_NORMAL_SETTINGS & 3) == 2
	vec2 i = sin(M_PI*t);
#if GRID_NORMAL_SETTINGS & 8
	vec2 xy = sin(0.5*M_PI*sin(2.0*M_PI*t));
	vec2 z = 0.5*sin(0.5*M_PI*cos(2.0*M_PI*t)) + 0.5;
#else
	vec2 xy = sin(2.0*M_PI*t);
	vec2 z = 0.5*cos(2.0*M_PI*t) + 0.5;
#endif

	vec3 normal;
	if(i.x > i.y) normal = vec3(-xy.x, 0.0, z.x);
	else normal = vec3(0.0, xy.y, z.y);

    normal = normalize(normal);
#elif (GRID_NORMAL_SETTINGS & 3) == 3
	vec2 i = sin(M_PI*t);
#if GRID_NORMAL_SETTINGS & 8
	vec2 xy = sin(0.5*M_PI*sin(2.0*M_PI*t));
	vec2 z = 0.5*sin(0.5*M_PI*cos(2.0*M_PI*t)) + 0.5;
#else
	vec2 xy = sin(2.0*M_PI*t);
	vec2 z = 0.5*cos(2.0*M_PI*t) + 0.5;
#endif
	
	vec3 normal = vec3(0.0, 0.0, max(z.x, z.y));
	if(i.x > i.y) normal.x = -xy.x;
	else normal.y = xy.y;

    normal = normalize(normal);
#endif

#if GRID_NORMAL_SETTINGS & 4
	normal.xy = -normal.xy;
#endif

    return normal;
}

float compute_grid_factor(vec2 uv) {
	float l = general_settings.length_scale;
	//if(uv.s <= -l || uv.s >= l)// || uv.t <= -1.0 || uv.t >= 1.0)
	//	return 0.0;

	float grid_factor = 0.0;
	grid_factor = grids[0].blend_factor * grid_texture(grids[0].scaling*uv, grids[0].thickness);
	grid_factor = max(grid_factor, grids[1].blend_factor * grid_texture(grids[1].scaling*uv, grids[1].thickness));
	return min(grid_factor, 1.0);
}

vec3 compute_grid_normal(vec2 uv) {
	float l = general_settings.length_scale;
	//if(uv.s <= -l || uv.s >= l)// || uv.t <= -1.0 || uv.t >= 1.0)
	//	return vec3(0.0, 0.0, 1.0);
	
	vec3 normal = vec3(0.0, 0.0, 1.0);
	vec3 normal0 = mix(normal, grid_normal(grids[0].scaling*uv, grids[0].thickness), grids[0].blend_factor);
	vec3 normal1 = mix(normal, grid_normal(grids[1].scaling*uv, grids[1].thickness), grids[1].blend_factor);

	float grid_blend_factor = grid_texture(grids[0].scaling*uv, grids[0].thickness);
	return normalize(mix(normal0, normal1, 1.0 - grid_blend_factor));
}

// code for drawing digits from https://www.shadertoy.com/view/lsXXzN
// adjusted to own needs
float segment(vec2 uv, bool on) {
	return on ? (1.0 - smoothstep(0.08, 0.09 + float(on)*0.02, abs(uv.x))) *
			    (1.0 - smoothstep(0.46, 0.47 + float(on)*0.02, abs(uv.y) + abs(uv.x)))
		        : 0.0;
}

float digit(vec2 uv, uint num) {
	float seg = 0.0;
    seg += segment(uv.yx + vec2(-1.0, +0.0), num!=1 && num!=4                    );
	seg += segment(uv.xy + vec2(-0.5, -0.5), num!=1 && num!=2 && num!=3 && num!=7);
	seg += segment(uv.xy + vec2(+0.5, -0.5), num!=5 && num!=6                    );
   	seg += segment(uv.yx + vec2(+0.0, +0.0), num!=0 && num!=1 && num!=7          );
	seg += segment(uv.xy + vec2(-0.5, +0.5), num==0 || num==2 || num==6 || num==8);
	seg += segment(uv.xy + vec2(+0.5, +0.5), num!=2                              );
    seg += segment(uv.yx + vec2(+1.0, +0.0), num!=1 && num!=4 && num!=7          );	
	return seg;
}

vec4 splat_generic_glyph(in uint debug_info, in float dist, in vec3 glyph_color) {
	
	// debug only
	// show otherwise not drawn glyphs
	float alpha_fac = 1.0;
	if((debug_info & 0x1000) == 0) {
		alpha_fac = 0.5; // make glyph half transparent
		dist = op_onion(dist + 0.05, 0.05); // draw outline of glyph (keeps original size)
	}

	// >> non-debuig implementation
	// pre-filter the SDF for AA
	const float antialias_width = general_settings.antialias_radius*fwidth(dist);
	float alpha = 1.0 - smoothstep(-antialias_width, antialias_width, dist);
	return vec4(glyph_color, alpha_fac * alpha);
	//return mix(glyph_color, color, smoothstep(-antialias_width, antialias_width, dist));
	// <<
}

void finalize_glyph(in uint debug_info, in vec2 uv, in vec4 glyph_color, inout vec3 color) {

	// the following is for debugging only
	uint main_attrib_idx = (debug_info>>2) & 0x0003;
	uint interpolated_attrib_count = debug_info & 0x0003;
	
	// color according to main attribute (the one, that induced the placement of this glyph)
	//glyph_color.rgb = vec3(0.0);
	//glyph_color.rgb[main_attrib_idx] = 1.0;

	// >> non-debug implementation
	color = mix(color, glyph_color.rgb, glyph_color.a);
	// <<

	// number overlay (debug only)
	// draw a digit showing the number of interpolated attributes for the current glyph
	//vec2 digit_uv = -6.0 * uv;
	//color = mix(color, 1.0-color, digit(digit_uv, interpolated_attrib_count));
}

void splat_glyph2(in uint debug_info, in vec2 uv, in float dist, in vec3 glyph_color, inout vec3 color) {
	// the following is for debugging only
	uint main_attrib_idx = (debug_info>>2) & 0x0003;
	uint interpolated_attrib_count = debug_info & 0x0003;
	
	glyph_color = vec3(0.0);
	glyph_color[main_attrib_idx] = 1.0;

	if((debug_info & 0x1000) == 0) {
		// this is for showing otherwise not drawn glyphs
		glyph_color = mix(color, glyph_color, 0.5); // make glyph half transparent
		dist = op_onion(dist + 0.05, 0.05); // draw outline of glyph (keeps original size)
	}

	// pre-filter the SDF for AA
	const float antialias_width = general_settings.antialias_radius*fwidth(dist);
	color = mix(glyph_color, color, smoothstep(-antialias_width, antialias_width, dist));

	// draw a digit showing the number of interpolated attributes for the current glyph
	vec2 digit_uv = -6.0 * uv;
	color = mix(color, 1.0-color, digit(digit_uv, interpolated_attrib_count));

	digit_uv = 2.0 * digit_uv;

	/*float value = gd.radius;

	float decimal_dot = sd_circle(digit_uv + vec2(0.0, 1.0), 0.15) < 0.0 ? 1.0 : 0.0;

	float digit0 = digit(digit_uv - vec2(1.0, 0.0), uint(value));
	value -= float(uint(value));
	value *= 10.0;
	float digit1 = digit(digit_uv + vec2(1.0, 0.0), uint(value));
	value -= float(uint(value));
	value *= 10.0;
	float digit2 = digit(digit_uv + vec2(3.0, 0.0), uint(round(value)));

	vec3 icol = 1.0 - color;

	color = mix(color, icol, digit0);
	color = mix(color, icol, digit1);
	color = mix(color, icol, digit2);
	color = mix(color, icol, decimal_dot);*/
}

void main()
{
	vec4 albedo_texcoord_seg = texture(albedo_tex, texcoord_fs);
	vec3 color = unpackUnorm4x8(floatBitsToUint(albedo_texcoord_seg.x)).rgb;
	vec2 texcoord = albedo_texcoord_seg.yz;
	int segment_id = floatBitsToInt(albedo_texcoord_seg.w);

	vec3 pos_eye = texture(position_tex, texcoord_fs).xyz;
	vec3 normal_eye = texture(normal_tex, texcoord_fs).xyz;
	vec3 tangent_eye = texture(tangent_tex, texcoord_fs).xyz;
	float depth = texture(depth_tex, texcoord_fs).r;

	if(depth == 1.0) {
		vec3 background_color = vec3(0.0);
		frag_color = vec4(background_color, 1.0);
	} else {
		vec2 uv = texcoord;

		// Transform the texture coordinate v to go around the tube twice, i.e. from [0,1] to [0,2].
		// That way the front side of the tube (half the radius), that is always visible to the camera,
		// has coordinates in [0,1], while the back side lies in [1,2].
		uv.t *= 2.0;
		// Move the origin (0,0) to the center of the front side and scale the v coordinate to [-1,1]
		uv.t = 2.0 * uv.t - 1.0;

		// Correct the perspective shift caused by the curved tube surface by rescaling the v coordinate around the tube.
		if(general_settings.use_curvature_correction)
			uv.t = sin(0.5*M_PI*uv.t);

		//frag_color = vec4(uv.s, uv.t, 0.0, 1.0);

		/*closest_glyphs_info closest;
		
		if (get_closest_samples(closest, segment_id, uv.s))
		{
			glyph_desc current_glyph = glyphs[closest.id];

			vec2 glyphuv = vec2(
				  (closest.dp <= closest.dn ? closest.dp : -closest.dn)
				* general_settings.length_scale, // <-- ToDo: replace with automatic uv re-projection method
				uv.t
			);

			GLYPH_LAYER_DEFINITION
		}*/


		
		// glyph layer 0
#if L0_MAPPED_ATTRIB_COUNT > 0
		{
			closest_glyphs_info closest;
			vec2 glyphuv = uv;
			if (get_closest_samples0(segment_id, glyphuv.s, closest)) {
				glyph_desc0 glyph = glyphs0[closest.id];

				glyphuv = vec2(
					(closest.dp <= closest.dn ? closest.dp : -closest.dn)
					* general_settings.length_scale, // <-- ToDo: replace with automatic uv re-projection method
					glyphuv.t
				);

				L0_GLYPH_DEFINITION
			}
		}
#endif
		// glyph layer 1
#if L1_MAPPED_ATTRIB_COUNT > 0
		{
			closest_glyphs_info closest;
			vec2 glyphuv = uv;
			if (get_closest_samples1(segment_id, glyphuv.s, closest)) {
				glyph_desc1 glyph = glyphs1[closest.id];

				glyphuv = vec2(
					(closest.dp <= closest.dn ? closest.dp : -closest.dn)
					* general_settings.length_scale, // <-- ToDo: replace with automatic uv re-projection method
					glyphuv.t
				);

				L1_GLYPH_DEFINITION
			}
		}
#endif
		// glyph layer 2
#if L2_MAPPED_ATTRIB_COUNT > 0
		{
			closest_glyphs_info closest;
			vec2 glyphuv = uv;
			if (get_closest_samples2(segment_id, glyphuv.s, closest)) {
				glyph_desc2 glyph = glyphs2[closest.id];

				glyphuv = vec2(
					(closest.dp <= closest.dn ? closest.dp : -closest.dn)
					* general_settings.length_scale, // <-- ToDo: replace with automatic uv re-projection method
					glyphuv.t
				);

				L2_GLYPH_DEFINITION
			}
		}
#endif
		// glyph layer 3
#if L3_MAPPED_ATTRIB_COUNT > 0
		{
			closest_glyphs_info closest;
			vec2 glyphuv = uv;
			if (get_closest_samples3(segment_id, glyphuv.s, closest)) {
				glyph_desc3 glyph = glyphs3[closest.id];

				glyphuv = vec2(
					(closest.dp <= closest.dn ? closest.dp : -closest.dn)
					* general_settings.length_scale, // <-- ToDo: replace with automatic uv re-projection method
					glyphuv.t
				);

				L3_GLYPH_DEFINITION
			}
		}
#endif

#if DEBUG_SEGMENTS > 0
		// highlight individual segments
		if((segment_id&1) > 0) color *= 0.5;
#endif

		/*glyph_desc current_glyph;
		vec2 glyphuv = uv;
		if(get_current_glyph(current_glyph, segment_id, glyphuv)) {
			GLYPH_LAYER_DEFINITION
		}*/


#if GRID_MODE & 1
		color = mix(color, grid_color.rgb, compute_grid_factor(uv) * grid_color.a);
#endif

		frag_color = compute_reflected_appearance(pos_eye, normal_eye, vec4(color, 1.0), 1);

#if GRID_MODE & 2
		vec3 gn = compute_grid_normal(uv);
		vec3 bitangent_eye = cross(normal_eye, tangent_eye);
		mat3 TBN = mat3(tangent_eye, bitangent_eye, normal_eye);
		vec3 normal_eye_bump = mix(normal_eye, normalize(TBN * gn), normal_mapping_scale);
		vec4 frag_color_bump = compute_reflected_appearance(pos_eye, normal_eye_bump, vec4(color, 1.0), 1);
		//color = 0.5*gn+0.5;
		float aa_factor = min(aa_texture(grids[0].scaling*uv, grids[0].thickness, 0.5) + aa_texture(grids[1].scaling*uv, grids[1].thickness, 0.5), 1);
		frag_color = mix(frag_color, frag_color_bump, aa_factor);
#endif

		if(ambient_occlusion.enable)
			frag_color.rgb *= compute_ambient_occlusion_factor(pos_eye, normal_eye);

		//frag_color = vec4(vec3(texcoord.x), 1.0);
	}

	if(use_gamma)
		frag_color.rgb = pow(frag_color.rgb, vec3(2.2));
	
	// write the frag depth to enable the framework view to work properly
	gl_FragDepth = depth;
}