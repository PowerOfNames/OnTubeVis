#version 430
#define M_PI 3.14159265359

#define GRID_MODE 1
#define ENABLE_FUZZY_GRID 0
#define GRID_NORMAL_SETTINGS 0
#define GLYPH_MAPPING_UNIFORMS
#define GLYPH_ATTRIBUTES_DEFINITION float radius0, radius1, angle0, angle1;
#define GLYPH_LAYER_DEFINITION

//***** begin interface of view.glsl ***********************************
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
//***** end interface of view.glsl ***********************************

////***** begin interface of surface.glsl ***********************************
vec4 compute_reflected_appearance(vec3 position_eye, vec3 normal_eye, vec4 color, int side);
////***** end interface of surface.glsl ***********************************

layout (binding = 0) uniform sampler2D albedo_tex;
layout (binding = 1) uniform sampler2D position_tex;
layout (binding = 2) uniform sampler2D normal_tex;
layout (binding = 3) uniform sampler2D tangent_tex;
layout (binding = 4) uniform sampler2D info_tex;
layout (binding = 5) uniform sampler2D depth_tex;
layout (binding = 6) uniform sampler3D density_tex;

// basic rendering parameters
//uniform vec3 background_color;
uniform bool use_gamma = false;

// ambient occlusion parameters
uniform struct {
	bool enable;
	float sample_offset;
	float sample_distance;
	float strength_scale;
	vec3 tex_offset;
	vec3 tex_scaling;
	vec3 texcoord_scaling;
	float texel_size;
	float cone_angle_factor;
	vec3 sample_directions[3];
} ambient_occlusion;

// grid parameters
struct grid_parameters {
	vec2 scaling;
	float thickness;
	float blend_factor;
};
uniform vec4 grid_color;
uniform float normal_mapping_scale = 1.0;
uniform grid_parameters grids[2];

// attribute mapping parameters
GLYPH_MAPPING_UNIFORMS

uniform struct {
	bool use_curvature_correction;
	float length_scale; // only for testing purposes
	float antialias_radius;
} general_settings;

/*uniform struct {
	int glyph_type;
	bool curvature_correction;
	float radius0;
	float radius1;
	float angle0;
	float angle1;
	
	float length_scale;
} attribute_mapping;*/



// free attributes ssbo
struct glyph_desc {
	float s;
	GLYPH_ATTRIBUTES_DEFINITION
};
layout (std430, binding=0) readonly buffer attribs_buffer { 
	glyph_desc glyphs[];
};

// free attributes per-segment index ranges
struct irange {
	int i0, n;
};
layout (std430, binding=1) readonly buffer ranges_buffer { 
	irange ranges[];
};

in vec2 texcoord_fs;

out vec4 frag_color;

struct closest_glyphs_info {
	int prev, next, id;
	float dp, dn, d;
};

bool get_closest_samples (out closest_glyphs_info closest, in int segid, in float s)
{
	const irange segment = ranges[segid];
	if (segment.n > 0)
	{
		// perform binary search
		irange rng = segment;
		while (rng.n > 1)
		{
			const int mid_n = rng.n/2, mid = rng.i0+mid_n;
			if (glyphs[mid].s > s)
				// left node
				rng.n = mid_n;
			else
			{
				// right node
				rng.i0 = rng.i0 + mid_n;
				rng.n  = rng.n  - mid_n;
			}
		}
		closest.prev = rng.i0;
		closest.next = rng.i0 < segment.i0+segment.n-1 ? rng.i0+1 : rng.i0;
		closest.dp = s-glyphs[rng.i0].s;
		closest.dn = glyphs[closest.next].s-s;
		const bool n_lt_p = closest.dn < closest.dp;
		closest.id = n_lt_p ? closest.next : closest.prev;
		closest.d  = n_lt_p ? closest.dn : closest.dp;
		return true;
	}
	return false;
}

float compute_ambient_occlusion_factor(in vec3 pos_eye, in vec3 normal_eye) {
	vec3 pos = (get_inverse_modelview_matrix() * vec4(pos_eye, 1.0)).xyz;
	vec3 normal = normalize(get_inverse_normal_matrix() * normal_eye);

	// do voxel cone tracing to determine occlusion of ambient light
	float ao = 0.0;

	mat3 R;
	R[1] = normal;
	R[0] = cross(R[1], normalize(pos));
	R[2] = cross(R[0], R[1]);

	for(int i = 0; i < 3; ++i) {
		vec3 sd = R * ambient_occlusion.sample_directions[i];

		float sample_distance = ambient_occlusion.sample_offset + 0.001;
		vec3 normalized_pos = (pos - ambient_occlusion.tex_offset) * ambient_occlusion.tex_scaling;
		float lod_texel_size = 0.0f;
			
		float illumination = 1.0;

		do {
			// get cone base radius at current distance and then the according mipmap sample level
			float cone_radius = sample_distance * ambient_occlusion.cone_angle_factor;
			float sample_level = clamp(log2(cone_radius / ambient_occlusion.texel_size), 0.0, 7.0);

			lod_texel_size = pow(2.0, sample_level) * ambient_occlusion.texel_size;

			vec3 sample_pos = normalized_pos + sample_distance * sd * ambient_occlusion.texcoord_scaling;
			float density = textureLod(density_tex, sample_pos, sample_level).r;
			// apply the compositing function
			illumination *= 1.0 - density * illumination;

			// get the next sample distance and position
			sample_distance += cone_radius;
		} while(sample_distance < ambient_occlusion.sample_distance - lod_texel_size && illumination > 0.02);

		ao += (1.0 - illumination);
	}

	return 1.0 - clamp(ambient_occlusion.strength_scale * ao / 3.0, 0.0, 1.0);
}

// rotate a 2d point by the given angle in radians
vec2 rotate(in vec2 p, in float a) {
	const float quarter_turn = 1.57079632679; // additional rotation of 90 degrees, so an angle of 0 degrees points the glyph into the direction of the segment
	a += quarter_turn;
	float as = sin(a);
	float ac = cos(a);
	return mat2(ac, as, -as, ac) * p;
}					

float op_subtract(float d0, float d1) {
	return max(-d0, d1);
}

// SDFs from https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm

// r is the radius of the circle
float sd_circle(in vec2 p, in float r) {
    return length(p) - r;
}

// a is the width/length of the rectangle
// b is the height of the rectangle
float sd_rectangle(in vec2 p, in float a, in float b) {
    vec2 d = abs(p)-0.5*vec2(a,b);
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

// r is the radius of the circle wedge
// a is the aperture angle in radians
float sd_wedge(in vec2 p, in float r, in float a) {
	vec2 sca = vec2(sin(a), cos(a));

    p.x = abs(p.x);
    float l = length(p) - r;
    float m = length(p-sca*clamp(dot(p,sca),0.0,r));
    return max(l,m*sign(sca.y*p.x-sca.x*p.y));
}

// ra is the radius of the arc
// rb is the radius of the stroke
// a is the aperture angle in radians
float sd_arc_flat(in vec2 p, in float ra, in float rb, in float a) {
	float d0 = sd_wedge(p, ra + rb, a);
	float d1 = sd_circle(p, ra - rb);
	return op_subtract(d1, d0);
}

// ra is the radius of the arc
// rb is the radius of the stroke
// a is the aperture angle in radians
float sd_arc_rounded(in vec2 p, in float ra, in float rb, in float a) {
	vec2 sca = vec2(sin(a), cos(a));
    p.x = abs(p.x);
    float k = (sca.y*p.x>sca.x*p.y) ? dot(p,sca) : length(p);
    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;
}

/*
	Currently the triangle is centered and rotates around the tip. To center it to the middle of the height use:
	sd = sd_triangle_isosceles(
		rotate(glyphuv, radians(current_glyph.angle1)) - vec2(0.0, current_glyph.radius1),
		vec2(current_glyph.radius0, -2.0*current_glyph.radius1)
	);
*/
// bw is the base width of the triangle
// h is the height of the triangle
float sd_triangle_isosceles(in vec2 p, in float bw, in float h) {
	vec2 q = vec2(bw, h);
    p.x = abs(p.x);
    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );
    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );
    float s = -sign( q.y );
    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),
                  vec2( dot(b,b), s*(p.y-q.y) ));
    return -sqrt(d.x)*sign(d.y);
}

// r1 is the base radius
// r2 is the tip radius0
// h is the height/length of the capsule
// alternative name: uneven_capsule
float sd_drop(vec2 p, float r1, float r2, float h) {
    p.x = abs(p.x);
    float b = (r1 - r2) / h;
    float a = sqrt(1.0 - b*b);
    float k = dot(p, vec2(-b, a));
    if(k < 0.0)
		return length(p) - r1;
    if(k > a*h)
		return length(p - vec2(0.0, h)) - r2;
    return dot(p, vec2(a, b)) - r1;
}

float grid_texture_fuzzy(in vec2 p, in float n) {
	// coordinates
	vec2 s = fract(p + 0.5*n);
	vec2 t = clamp(s / n, 0.0, 1.0);

	vec2 i = sin(M_PI*t);
	return max(i.x, i.y);
}

float grid_texture_aa(in vec2 p, in float n, float aa_strength) {
	// pre-filter AA preparations
	const float na = n*0.5, nb = 1.0-n*0.5;
	const vec2 p_frac = fract(p), w = aa_strength*fwidth(p);

	// coordinates
	const vec2 i = vec2(1) - smoothstep(na-w, na+w, p_frac) + smoothstep(nb-w, nb+w, p_frac);

	//pattern (from https://www.shadertoy.com/view/XtBfzz)
	return 1.0 - (1.0-i.s)*(1.0-i.t);	// grid
	//return 1.0-i.s*i.t;				// squares
	//return 1.0-i.s-i.t+2.0*i.s*i.t;	// checker
}

float grid_texture(in vec2 p, in float n) {
#if ENABLE_FUZZY_GRID == 1
	return grid_texture_fuzzy(p, n);
#else
	return grid_texture_aa(p, n , 1);
#endif
}

float aa_texture(in vec2 p, in float n, float aa_strength) {
	// pre-filter AA preparations
	const float na = n*0.5, nb = 1.0-n*0.5;
	const vec2 p_frac = fract(p), w = 2*aa_strength*fwidth(p);

	// coordinates
	const vec2 i = vec2(1) - smoothstep(na-w, vec2(na), p_frac) + smoothstep(vec2(nb), nb+w, p_frac);

	//pattern (from https://www.shadertoy.com/view/XtBfzz)
	return 1.0 - (1.0-i.s)*(1.0-i.t);	// grid
	//return 1.0-i.s*i.t;				// squares
	//return 1.0-i.s-i.t+2.0*i.s*i.t;	// checker
}

vec3 grid_normal(in vec2 p, in float n) {

	// coordinates
	vec2 s = fract(p + 0.5*n);
	vec2 t = clamp(s / n, 0.0, 1.0);

#if (GRID_NORMAL_SETTINGS & 3) == 0
#if GRID_NORMAL_SETTINGS & 8
	vec2 xy = sin(0.5*M_PI*sin(2.0*M_PI*t));
	vec2 z = 0.5*sin(0.5*M_PI*cos(2.0*M_PI*t)) + 0.5;
#else
	vec2 xy = sin(2.0*M_PI*t);
	vec2 z = 0.5*cos(2.0*M_PI*t) + 0.5;
#endif
	vec3 normal = normalize(vec3(-xy.x, xy.y, max(z.x, z.y)));
#elif (GRID_NORMAL_SETTINGS & 3) == 1
	vec2 i = sin(M_PI*t);
	vec2 xy = sin(2.0*M_PI*t);

	vec3 normal = vec3(0.0, 0.0, 0.0);
#if GRID_NORMAL_SETTINGS & 8
	vec3 n0 = vec3(-xy.x, 0.0, 0.0);
	vec3 n1 = vec3(0.0, xy.y, 0.0);

	float d = abs(i.x - i.y);
	float sum = i.x + i.y;

	if(i.x > i.y) normal = n0;
	else normal = n1;

	if(d < 0.2) {
		float a = 1.0 - d / 0.2;
		vec3 n2 = 0.5*(n0 + n1);
		normal = mix(normal, n2, a);
	}
	float v = normal.x*normal.x + normal.y*normal.y;
	normal.z = (v >= 0.99999) ? 0.0 : sqrt(1.0 - v);
#else
	if(i.x > i.y) normal.x = -xy.x;
	else normal.y = xy.y;

	float v = normal.x + normal.y;
	v *= v;
	normal.z = (v >= 0.99999) ? 0.0 : sqrt(1.0 - v);
#endif

#elif (GRID_NORMAL_SETTINGS & 3) == 2
	vec2 i = sin(M_PI*t);
#if GRID_NORMAL_SETTINGS & 8
	vec2 xy = sin(0.5*M_PI*sin(2.0*M_PI*t));
	vec2 z = 0.5*sin(0.5*M_PI*cos(2.0*M_PI*t)) + 0.5;
#else
	vec2 xy = sin(2.0*M_PI*t);
	vec2 z = 0.5*cos(2.0*M_PI*t) + 0.5;
#endif

	vec3 normal;
	if(i.x > i.y) normal = vec3(-xy.x, 0.0, z.x);
	else normal = vec3(0.0, xy.y, z.y);

    normal = normalize(normal);
#elif (GRID_NORMAL_SETTINGS & 3) == 3
	vec2 i = sin(M_PI*t);
#if GRID_NORMAL_SETTINGS & 8
	vec2 xy = sin(0.5*M_PI*sin(2.0*M_PI*t));
	vec2 z = 0.5*sin(0.5*M_PI*cos(2.0*M_PI*t)) + 0.5;
#else
	vec2 xy = sin(2.0*M_PI*t);
	vec2 z = 0.5*cos(2.0*M_PI*t) + 0.5;
#endif
	
	vec3 normal = vec3(0.0, 0.0, max(z.x, z.y));
	if(i.x > i.y) normal.x = -xy.x;
	else normal.y = xy.y;

    normal = normalize(normal);
#endif

#if GRID_NORMAL_SETTINGS & 4
	normal.xy = -normal.xy;
#endif

    return normal;
}

float compute_grid_factor(vec2 uv) {
	float l = general_settings.length_scale;
	//if(uv.s <= -l || uv.s >= l)// || uv.t <= -1.0 || uv.t >= 1.0)
	//	return 0.0;

	float grid_factor = 0.0;
	grid_factor = grids[0].blend_factor * grid_texture(grids[0].scaling*uv, grids[0].thickness);
	grid_factor = max(grid_factor, grids[1].blend_factor * grid_texture(grids[1].scaling*uv, grids[1].thickness));
	return min(grid_factor, 1.0);
}

vec3 compute_grid_normal(vec2 uv) {
	float l = general_settings.length_scale;
	//if(uv.s <= -l || uv.s >= l)// || uv.t <= -1.0 || uv.t >= 1.0)
	//	return vec3(0.0, 0.0, 1.0);
	
	vec3 normal = vec3(0.0, 0.0, 1.0);
	vec3 normal0 = mix(normal, grid_normal(grids[0].scaling*uv, grids[0].thickness), grids[0].blend_factor);
	vec3 normal1 = mix(normal, grid_normal(grids[1].scaling*uv, grids[1].thickness), grids[1].blend_factor);

	float grid_blend_factor = grid_texture(grids[0].scaling*uv, grids[0].thickness);
	return normalize(mix(normal0, normal1, 1.0 - grid_blend_factor));
}

void splat_glyph(in float dist, in vec3 glyph_color, inout vec3 color) {
	// pre-filter the SDF for AA
	const float antialias_width = general_settings.antialias_radius*fwidth(dist);
	color = mix(glyph_color, color, smoothstep(-antialias_width, antialias_width, dist));
}

void main()
{
	vec4 albedo_texcoord_seg = texture(albedo_tex, texcoord_fs);
	vec3 color = unpackUnorm4x8(floatBitsToUint(albedo_texcoord_seg.x)).rgb;
	vec2 texcoord = albedo_texcoord_seg.yz;
	int segment_id = floatBitsToInt(albedo_texcoord_seg.w);

	vec3 pos_eye = texture(position_tex, texcoord_fs).xyz;
	vec3 normal_eye = texture(normal_tex, texcoord_fs).xyz;
	vec3 tangent_eye = texture(tangent_tex, texcoord_fs).xyz;
	float depth = texture(depth_tex, texcoord_fs).r;

	if(depth == 1.0) {
		vec3 background_color = vec3(0.0);
		frag_color = vec4(background_color, 1.0);
	} else {
		vec2 uv = texcoord;

		// Transform the texture coordinate v to go around the tube twice, i.e. from [0,1] to [0,2].
		// That way the front side of the tube (half the radius), that is always visible to the camera,
		// has coordinates in [0,1], while the back side lies in [1,2].
		uv.t *= 2.0;
		// Move the origin (0,0) to the center of the front side and scale the v coordinate to [-1,1]
		uv.t = 2.0 * uv.t - 1.0;

		// Correct the perspective shift caused by the curved tube surface by rescaling the v coordinate around the tube.
		if(general_settings.use_curvature_correction)
			uv.t = sin(0.5*M_PI*uv.t);

		//frag_color = vec4(uv.s, uv.t, 0.0, 1.0);
		
		closest_glyphs_info closest;
		if (get_closest_samples(closest, segment_id, uv.s))
		{
			glyph_desc current_glyph = glyphs[closest.id];

			vec2 glyphuv = vec2(
				  (closest.dp <= closest.dn ? closest.dp : -closest.dn)
				* general_settings.length_scale, // <-- ToDo: replace with automatic uv re-projection method
				uv.t
			);

			GLYPH_LAYER_DEFINITION
		}

#if GRID_MODE & 1
		color = mix(color, grid_color.rgb, compute_grid_factor(uv) * grid_color.a);
#endif

		frag_color = compute_reflected_appearance(pos_eye, normal_eye, vec4(color, 1.0), 1);

#if GRID_MODE & 2
		vec3 gn = compute_grid_normal(uv);
		vec3 bitangent_eye = cross(normal_eye, tangent_eye);
		mat3 TBN = mat3(tangent_eye, bitangent_eye, normal_eye);
		vec3 normal_eye_bump = mix(normal_eye, normalize(TBN * gn), normal_mapping_scale);
		vec4 frag_color_bump = compute_reflected_appearance(pos_eye, normal_eye_bump, vec4(color, 1.0), 1);
		//color = 0.5*gn+0.5;
		float aa_factor = min(aa_texture(grids[0].scaling*uv, grids[0].thickness, 0.5) + aa_texture(grids[1].scaling*uv, grids[1].thickness, 0.5), 1);
		frag_color = mix(frag_color, frag_color_bump, aa_factor);
#endif

		if(ambient_occlusion.enable)
			frag_color.rgb *= compute_ambient_occlusion_factor(pos_eye, normal_eye);

		//frag_color = vec4(vec3(texcoord.x), 1.0);
	}

	if(use_gamma)
		frag_color.rgb = pow(frag_color.rgb, vec3(2.2));
	
	// write the frag depth to enable the framework view to work properly
	gl_FragDepth = depth;
}