#version 430
#define M_PI 3.14159265359

#define SHOW_GLYPHS 1
#define GRID_MODE 1
#define ENABLE_GRID_SMOOTHING 0
#define GRID_NORMAL_SETTINGS 0

//***** begin interface of view.glsl ***********************************
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
//***** end interface of view.glsl ***********************************

////***** begin interface of surface.glsl ***********************************
vec4 compute_reflected_appearance(vec3 position_eye, vec3 normal_eye, vec4 color, int side);
////***** end interface of surface.glsl ***********************************

layout (binding = 0) uniform sampler2D albedo_tex;
layout (binding = 1) uniform sampler2D position_tex;
layout (binding = 2) uniform sampler2D normal_tex;
layout (binding = 3) uniform sampler2D tangent_tex;
layout (binding = 4) uniform sampler2D depth_tex;
layout (binding = 5) uniform sampler3D density_tex;

// basic rendering parameters
//uniform vec3 background_color;
uniform bool use_gamma = false;

// ambient occlusion parameters
uniform struct {
	bool enable;
	float sample_offset;
	float sample_distance;
	float strength_scale;
	vec3 tex_offset;
	vec3 tex_scaling;
	vec3 texcoord_scaling;
	float texel_size;
	float cone_angle_factor;
	vec3 sample_directions[3];
} ambient_occlusion;

// grid parameters
struct grid_parameters {
	vec2 scaling;
	float thickness;
	float blend_factor;
};
uniform vec4 grid_color;
uniform float normal_mapping_scale = 1.0;
uniform grid_parameters grids[2];

// attribute mapping parameters
uniform struct {
	int glyph_type;
	bool curvature_correction;
	float radius0;
	float radius1;
	float angle0;
	float angle1;
	// only for testing purposes
	float length_scale;
} attribute_mapping;

in vec2 texcoord_fs;

out vec4 frag_color;

float compute_ambient_occlusion_factor(in vec3 pos_eye, in vec3 normal_eye) {
	vec3 pos = (get_inverse_modelview_matrix() * vec4(pos_eye, 1.0)).xyz;
	vec3 normal = normalize(get_inverse_normal_matrix() * normal_eye);

	// do voxel cone tracing to determine occlusion of ambient light
	float ao = 0.0;

	mat3 R;
	R[1] = normal;
	R[0] = cross(R[1], normalize(pos));
	R[2] = cross(R[0], R[1]);

	for(int i = 0; i < 3; ++i) {
		vec3 sd = R * ambient_occlusion.sample_directions[i];

		float sample_distance = ambient_occlusion.sample_offset + 0.001;
		vec3 normalized_pos = (pos - ambient_occlusion.tex_offset) * ambient_occlusion.tex_scaling;
		float lod_texel_size = 0.0f;
			
		float illumination = 1.0;

		do {
			// get cone base radius at current distance and then the according mipmap sample level
			float cone_radius = sample_distance * ambient_occlusion.cone_angle_factor;
			float sample_level = clamp(log2(cone_radius / ambient_occlusion.texel_size), 0.0, 7.0);

			lod_texel_size = pow(2.0, sample_level) * ambient_occlusion.texel_size;

			vec3 sample_pos = normalized_pos + sample_distance * sd * ambient_occlusion.texcoord_scaling;
			float density = textureLod(density_tex, sample_pos, sample_level).r;
			// apply the compositing function
			illumination *= 1.0 - density * illumination;

			// get the next sample distance and position
			sample_distance += cone_radius;
		} while(sample_distance < ambient_occlusion.sample_distance - lod_texel_size && illumination > 0.02);

		ao += (1.0 - illumination);
	}

	return 1.0 - clamp(ambient_occlusion.strength_scale * ao / 3.0, 0.0, 1.0);
}

// SDFs from https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
float sd_circle(in vec2 p, in float r) {
    return length(p) - r;
}

float sd_rect(in vec2 p, in vec2 b) {
    vec2 d = abs(p)-b;
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

// c is the sin/cos of the aperture
float sd_pie(in vec2 p, in vec2 c, in float r) {
    p.x = abs(p.x);
    float l = length(p) - r;
    float m = length(p-c*clamp(dot(p,c),0.0,r));
    return max(l,m*sign(c.y*p.x-c.x*p.y));
}

// sca is the sin/cos of the orientation
// scb is the sin/cos of the aperture
float sd_arc(in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb) {
    p *= mat2(sca.x,sca.y,-sca.y,sca.x);
    p.x = abs(p.x);
    float k = (scb.y*p.x>scb.x*p.y) ? dot(p,scb) : length(p);
    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;
}

// q is the base width/height of the triangle
float sd_triangle_isosceles(in vec2 p, in vec2 q) {
    p.x = abs(p.x);
    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );
    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );
    float s = -sign( q.y );
    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),
                  vec2( dot(b,b), s*(p.y-q.y) ));
    return -sqrt(d.x)*sign(d.y);
}

#if ENABLE_GRID_SMOOTHING == 0
// https://www.shadertoy.com/view/XtBfzz
float grid_texture(in vec2 p, in float n) {
    // coordinates
	vec2 i = step(fract(p + 0.5*n), vec2(n));

    //pattern
    return 1.0 - (1.0-i.x)*(1.0-i.y);	// grid
    //return 1.0-i.x*i.y;				// squares
    //return 1.0-i.x-i.y+2.0*i.x*i.y;	// checker
}
#else
float grid_texture(in vec2 p, in float n) {
    // coordinates
	vec2 s = fract(p + 0.5*n);
	vec2 t = clamp(s / n, 0.0, 1.0);

	vec2 i = sin(M_PI*t);
    return max(i.x, i.y);
}
#endif
vec3 grid_normal(in vec2 p, in float n) {
    // coordinates
	vec2 s = fract(p + 0.5*n);
	vec2 t = clamp(s / n, 0.0, 1.0);

#if (GRID_NORMAL_SETTINGS & 3) == 0
#if GRID_NORMAL_SETTINGS & 8
	vec2 xy = sin(0.5*M_PI*sin(2.0*M_PI*t));
	vec2 z = 0.5*sin(0.5*M_PI*cos(2.0*M_PI*t)) + 0.5;
#else
	vec2 xy = sin(2.0*M_PI*t);
	vec2 z = 0.5*cos(2.0*M_PI*t) + 0.5;
#endif
	vec3 normal = normalize(vec3(-xy.x, xy.y, max(z.x, z.y)));
#elif (GRID_NORMAL_SETTINGS & 3) == 1
	vec2 i = sin(M_PI*t);
	vec2 xy = sin(2.0*M_PI*t);

	vec3 normal = vec3(0.0, 0.0, 0.0);
#if GRID_NORMAL_SETTINGS & 8
	vec3 n0 = vec3(-xy.x, 0.0, 0.0);
	vec3 n1 = vec3(0.0, xy.y, 0.0);

	float d = abs(i.x - i.y);
	float sum = i.x + i.y;

	if(i.x > i.y) normal = n0;
	else normal = n1;

	if(d < 0.2) {
		float a = 1.0 - d / 0.2;
		vec3 n2 = 0.5*(n0 + n1);
		normal = mix(normal, n2, a);
	}
	float v = normal.x*normal.x + normal.y*normal.y;
	normal.z = (v >= 0.99999) ? 0.0 : sqrt(1.0 - v);
#else
	if(i.x > i.y) normal.x = -xy.x;
	else normal.y = xy.y;

	float v = normal.x + normal.y;
	v *= v;
	normal.z = (v >= 0.99999) ? 0.0 : sqrt(1.0 - v);
#endif

#elif (GRID_NORMAL_SETTINGS & 3) == 2
	vec2 i = sin(M_PI*t);
#if GRID_NORMAL_SETTINGS & 8
	vec2 xy = sin(0.5*M_PI*sin(2.0*M_PI*t));
	vec2 z = 0.5*sin(0.5*M_PI*cos(2.0*M_PI*t)) + 0.5;
#else
	vec2 xy = sin(2.0*M_PI*t);
	vec2 z = 0.5*cos(2.0*M_PI*t) + 0.5;
#endif

	vec3 normal;
	if(i.x > i.y) normal = vec3(-xy.x, 0.0, z.x);
	else normal = vec3(0.0, xy.y, z.y);

    normal = normalize(normal);
#elif (GRID_NORMAL_SETTINGS & 3) == 3
	vec2 i = sin(M_PI*t);
#if GRID_NORMAL_SETTINGS & 8
	vec2 xy = sin(0.5*M_PI*sin(2.0*M_PI*t));
	vec2 z = 0.5*sin(0.5*M_PI*cos(2.0*M_PI*t)) + 0.5;
#else
	vec2 xy = sin(2.0*M_PI*t);
	vec2 z = 0.5*cos(2.0*M_PI*t) + 0.5;
#endif
	
	vec3 normal = vec3(0.0, 0.0, max(z.x, z.y));
	if(i.x > i.y) normal.x = -xy.x;
	else normal.y = xy.y;

    normal = normalize(normal);
#endif

#if GRID_NORMAL_SETTINGS & 4
	normal.xy = -normal.xy;
#endif

    return normal;
}

float compute_grid_factor(vec2 uv) {
	float l = attribute_mapping.length_scale;
	//if(uv.s <= -l || uv.s >= l)// || uv.t <= -1.0 || uv.t >= 1.0)
	//	return 0.0;

	float grid_factor = 0.0;
	grid_factor = grids[0].blend_factor * grid_texture(grids[0].scaling*uv, grids[0].thickness);
	grid_factor = max(grid_factor, grids[1].blend_factor * grid_texture(grids[1].scaling*uv, grids[1].thickness));
	return min(grid_factor, 1.0);
}

vec3 compute_grid_normal(vec2 uv) {
	float l = attribute_mapping.length_scale;
	//if(uv.s <= -l || uv.s >= l)// || uv.t <= -1.0 || uv.t >= 1.0)
	//	return vec3(0.0, 0.0, 1.0);
	
	vec3 normal = vec3(0.0, 0.0, 1.0);
	vec3 normal0 = mix(normal, grid_normal(grids[0].scaling*uv, grids[0].thickness), grids[0].blend_factor);
	vec3 normal1 = mix(normal, grid_normal(grids[1].scaling*uv, grids[1].thickness), grids[1].blend_factor);

	float grid_blend_factor = grid_texture(grids[0].scaling*uv, grids[0].thickness);
	return normalize(mix(normal0, normal1, 1.0 - grid_blend_factor));
}

void main()
{
	vec4 albedo_texcoord_seg = texture(albedo_tex, texcoord_fs);
	vec3 color = unpackUnorm4x8(floatBitsToUint(albedo_texcoord_seg.x)).rgb;
	vec2 texcoord = albedo_texcoord_seg.yz;
	int segment_id = floatBitsToInt(albedo_texcoord_seg.w);

	vec3 pos_eye = texture(position_tex, texcoord_fs).xyz;
	vec3 normal_eye = texture(normal_tex, texcoord_fs).xyz;
	vec3 tangent_eye = texture(tangent_tex, texcoord_fs).xyz;
	float depth = texture(depth_tex, texcoord_fs).r;

	if(depth == 1.0) {
		vec3 background_color = vec3(0.0);
		frag_color = vec4(background_color, 1.0);
	} else {
		//color = vec3(1.0);
		
		vec2 uv = texcoord;

		// Transform the texture coordinate v to go around the tube twice, i.e. from [0,1] to [0,2].
		// That way the front side of the tube (half the radius), that is always visible to the camera,
		// has coordinates in [0,1], while the back side lies in [1,2].
		uv.t *= 2.0;
		// Move the origin (0,0) to the center of the front side and scale the coordinates to [-1,1]
		//uv = 2.0 * uv - 1.0;
		uv.t = 2.0 * uv.t - 1.0;

		uv.s *= attribute_mapping.length_scale;

		// Correct the perspective shift caused by the curved tube surface by rescaling the v coordinate around the tube.
		if(attribute_mapping.curvature_correction)
			uv.t = sin(0.5*M_PI*uv.t);

		//frag_color = vec4(uv.s, uv.t, 0.0, 1.0);

		//frag_color = vec4(10*length(dFdx(uv)), 10*length(dFdy(uv)), 0.0, 1.0);
		
#if SHOW_GLYPHS == 1
		float sd = 1e20;
		switch(attribute_mapping.glyph_type) {
		case 0:
			// circle with radius
			sd = sd_circle(uv, attribute_mapping.radius0);
			break;
		case 1:
			// rectangle (ring) with (width, length)
			sd = sd_rect(uv, vec2(attribute_mapping.radius0, attribute_mapping.radius1));
			break;
		case 2:
		{
			// pie (circle wedge) with aperture angle and radius
			float aperture_angle = radians(attribute_mapping.angle0);
			sd = sd_pie(
				uv,
				vec2(sin(aperture_angle), cos(aperture_angle)),
				attribute_mapping.radius0
			);
		}
			break;
		case 3:
		{
			// arc (donut wedge) with orientation, aperture angle and two radii
			float orientation_angle = radians(attribute_mapping.angle1);
			float aperture_angle = radians(attribute_mapping.angle0);
			sd = sd_arc(
				uv,
				vec2(sin(orientation_angle), cos(orientation_angle)),
				vec2(sin(aperture_angle), cos(aperture_angle)),
				attribute_mapping.radius0,
				attribute_mapping.radius1
			);
		}
			break;
		case 4:
		{
			// isosceles triangle (arrow tip) with base width and height
			// compute a rotation matrix to rotate the uv coordinates
			float angle = radians(attribute_mapping.angle0 + 90.0); // add 90 degree to make triangle point in direction of segment per default
			float as = sin(angle);
			float ac = cos(angle);
			mat2 rot = mat2(ac, as, -as, ac);

			sd = sd_triangle_isosceles(rot * uv - vec2(0.0, attribute_mapping.radius1), vec2(attribute_mapping.radius0, -2.0 * attribute_mapping.radius1));
		}
			break;
		}

		if(sd <= 0.0)
			color = vec3(1.0, 0.0, 0.0);
			//color = 1.0 - color;
#endif

#if GRID_MODE & 1
		color = mix(color, grid_color.rgb, compute_grid_factor(uv) * grid_color.a);
#endif
#if GRID_MODE & 2
		vec3 gn = compute_grid_normal(uv);
		vec3 bitangent_eye = cross(normal_eye, tangent_eye);
		mat3 TBN = mat3(tangent_eye, bitangent_eye, normal_eye);
		normal_eye = mix(normal_eye, normalize(TBN * gn), normal_mapping_scale);
		//color = 0.5*gn+0.5;
#endif
		frag_color = compute_reflected_appearance(pos_eye, normal_eye, vec4(color, 1.0), 1);

		if(ambient_occlusion.enable)
			frag_color.rgb *= compute_ambient_occlusion_factor(pos_eye, normal_eye);

		//frag_color = vec4(vec3(texcoord.x), 1.0);
	}

	if(use_gamma)
		frag_color.rgb = pow(frag_color.rgb, vec3(2.2));
	
	// write the frag depth to enable the framework view to work properly
	gl_FragDepth = depth;
}