#version 460
#define M_INV_PI 0.31830988618
#define ONE_OVER_THREE (1.0/3.0)

#define PRIMITIVE_INTERSECTOR 0
#define USE_CONSERVATIVE_DEPTH 0
#define USE_CUBIC_TANGENTS 1
#define USE_VIEW_SPACE_POSITION 1

#if USE_CONSERVATIVE_DEPTH == 1
#extension GL_ARB_conservative_depth : enable
#endif

#if PRIMITIVE_INTERSECTOR == 0
	#define PRIMITIVE_RUSSIG 1
#else
	#define PRIMITIVE_PHANTOM 1
#endif

/* 0: NO_OP
   1: RASTERIZE_DEBUG
   2: RAYCAST_DEBUG
   3: RAYCAST */
#define MODE 3

/* 0: All attributes in geom->frag interface
   1: No curve attributes in geom->frag interface
   2: No color attributes in geom->frag interface
   3: Attribute-less (except segment and sub-curve ids) */
#define ATTRIB_MODE 0

#define FLT_EPS 1.19209290e-07
#define POS_INF 3e+37
#define NEG_INF -3e+37
#define N0 3
#define N1 5

//***** begin interface of view.glsl ***********************************
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_inverse_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
//***** end interface of view.glsl ***********************************

struct TubeNode {
	vec3 pos;
	float rad;

	vec3 pos_tan;
	float rad_tan;
};

struct Tube {
	TubeNode s;
	TubeNode e;
};

struct QTubeNode {
	vec3 pos;
	float rad;
};

struct QTube {
	QTubeNode s;
	QTubeNode h;
	QTubeNode e;
};

struct Hit {
	float l;
	float t;
	vec3 normal;
	vec3 sp;
	bool cap;
};

uniform float radius_scale;
uniform vec3 eye_pos;
uniform vec4 viewport;
uniform float max_t;
uniform float cap_clip_distance;

struct node_data_type {
	vec4 pos_rad;
	vec4 color;
	vec4 tangent;
	vec4 t; // only uses .x component to store t, yzw are reserved for future use
};

// node attribute buffer
layout(std430, binding = 0) readonly buffer data_buffer {
    node_data_type nodes[];
};

// arclen approximations SBO
layout (std430, binding = 1) readonly buffer arclen_buffer { 
  mat4 b[]; // 4 cubic beziers packed into colums of mat4
};

// node index pair buffer
layout(std430, binding = 2) readonly buffer nid_buffer {
    uvec2 node_ids[];
};

#if USE_VIEW_SPACE_POSITION == 1
in vec3 position_fs;
#endif
in flat float l_offset_fs;
#if !(ATTRIB_MODE & 2)
	in flat uint color0_fs;
	in flat uint color1_fs;
#endif
#if !(ATTRIB_MODE & 1)
	in flat QTube qTube_fs;
#endif
in flat int segment_id_fs;
#if USE_CUBIC_TANGENTS == 1
in flat mat4 SM_fs; // spline matrix
#endif

#if USE_CONSERVATIVE_DEPTH == 1
layout (depth_greater) out float gl_FragDepth;
#endif

layout (location = 0) out vec4 frag_albedo;
layout (location = 1) out vec3 frag_position;
layout (location = 2) out vec3 frag_normal;
layout (location = 3) out vec3 frag_tangent;


float eval_cubic_bezier(float t, vec4 cp) {
	const vec4 monomials = vec4(1.0, t, t*t, t*t*t);
	const mat4 Mc = mat4(
		1, -3,  3, -1,
		0,  3, -6,  3,
		0,  0,  3, -3,
		0,  0,  0,  1
	);
	return dot(monomials, Mc * cp);
}

// arclength evaluation
// length scale should be set to 1/radius with curvature correction on
float alen (float t)
{
	const float t4 = t+t+t+t;
	const int seg = max(int(min(t4, 3)), 0);
	const float t_inner = t4 - seg;
	return eval_cubic_bezier(t_inner, b[segment_id_fs][seg]);
}

// Produces an orthogonal vector to v. Doesn�t require the input
// to be normalized and doesn�t normalise the output. 
// source: http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts
vec3 GetOrthoVec(vec3 v)
{
    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0f) : vec3(0.0f, -v.z, v.y);
}

// Constructs a model transformation from eye space to ray-centric coordinates where the ray
// defines the local x axis
mat3 calc_rcc_x (const vec3 dir)
{
	mat3 RCC;
	RCC[0] = dir;
	RCC[1] = normalize(GetOrthoVec(dir));
	RCC[2] = cross(dir, RCC[1]);
	return RCC;
}

// Constructs a model transformation from eye space to ray-centric coordinates where the ray
// defines the local z axis
mat3 calc_rcc_z (const vec3 dir)
{
	mat3 RCC;
	RCC[2] = dir;
	RCC[1] = normalize(GetOrthoVec(dir));
	RCC[0] = cross(dir, RCC[1]);
	return RCC;
}

float Pow2(float x) { return x * x; }
float Pow3(float x) { return x * x * x; }

vec2 SolveQuadratic(float a, float b, float c) {
    if(abs(a) < FLT_EPS) {
		if(abs(b) < FLT_EPS)
			return vec2(-2.0, 2.0);
		else
			return vec2(-c / b, 2.0);
    } else {
		float discr = b * b - 4.0 * a * c;
		if(abs(discr) < FLT_EPS) return vec2(-b / (2.0 * a), 2.0);
		if(discr < 0.0) return vec2(-2.0, 2.0);
		vec2 r = (-vec2(b) + vec2(-1.0, 1.0) * vec2(sqrt(discr))) / (2.0 * a);
		return r.x < r.y ? r.xy : r.yx;
    }
}

void Pow2(in float c[3], out float o_c[5]) {
	o_c[0] = c[0] * c[0]; 
	o_c[1] =  2.0 * c[0] * c[1];
	o_c[2] = c[1] * c[1] +  2.0 * c[0] * c[2];
	o_c[3] =  2.0 * c[2] * c[1];
	o_c[4] = c[2] * c[2];
}

void Sub(in float a[5], in float b[5], out float o_c[5]) {
	o_c[0] = a[0] - b[0];
	o_c[1] = a[1] - b[1];
	o_c[2] = a[2] - b[2];
	o_c[3] = a[3] - b[3];
	o_c[4] = a[4] - b[4];
}

float EvalPoly(float x, float c0, float c1, float c2, float c3, float c4, float c5, float c6) { return x * (x * (x * (x * (x * (x * c6 + c5) + c4) + c3) + c2) + c1) + c0; }
float EvalPoly(float x, float c0, float c1, float c2, float c3, float c4, float c5) { return EvalPoly(x, c0,c1,c2,c3,c4,c5,0.0); }
float EvalPoly(float x, float c0, float c1, float c2, float c3, float c4) { return EvalPoly(x, c0,c1,c2,c3,c4,0.0,0.0); }
float EvalPoly(float x, float c0, float c1, float c2, float c3) { return EvalPoly(x, c0,c1,c2,c3,0.0,0.0,0.0); }
float EvalPoly(float x, float c0, float c1, float c2) { return EvalPoly(x, c0,c1,c2,0.0,0.0,0.0,0.0); }
float EvalPoly(float x, float c0, float c1) { return EvalPoly(x, c0,c1,0.0,0.0,0.0,0.0,0.0); }
float EvalPoly(float x, float c0) { return EvalPoly(x, c0,0.0,0.0,0.0,0.0,0.0,0.0); }

//float EvalPolyD0(float x, float c[3]) { return EvalPoly(x, c[0], c[1], c[2]); }
//float EvalPolyD1(float x, float c[3]) { return EvalPoly(x, c[1], c[2]*2.f);   }
//float EvalPolyD2(float x, float c[3]) { return EvalPoly(x, c[2]*2.f);         }
//float EvalPolyD0(float x, float c[5]) { return EvalPoly(x, c[0], c[1], c[2], c[3], c[4]);       }
//float EvalPolyD1(float x, float c[5]) { return EvalPoly(x, c[1], c[2]*2.f, c[3]*3.f, c[4]*4.f); }
//float EvalPolyD2(float x, float c[5]) { return EvalPoly(x, c[2]*2.f, c[3]*6.f, c[4]*12.f);      }
//float EvalPolyD3(float x, float c[5]) { return EvalPoly(x, c[3]*6.f, c[4]*24.f);                }

// same as above, but multiplication wit 2, 3, or 4 is replaced with addition (gives a small performance boost)
float EvalPolyD0(float x, float c[3]) { return EvalPoly(x, c[0], c[1], c[2]); }
float EvalPolyD1(float x, float c[3]) { return EvalPoly(x, c[1], c[2]+c[2]);  }
float EvalPolyD2(float x, float c[3]) { return EvalPoly(x, c[2]+c[2]);        }
float EvalPolyD0(float x, float c[5]) { return EvalPoly(x, c[0], c[1], c[2], c[3], c[4]);                         }
float EvalPolyD1(float x, float c[5]) { return EvalPoly(x, c[1], c[2]+c[2], c[3]+c[3]+c[3], c[4]+c[4]+c[4]+c[4]); }
float EvalPolyD2(float x, float c[5]) { return EvalPoly(x, c[2]+c[2], c[3]*6.f, c[4]*12.f);                       }
float EvalPolyD3(float x, float c[5]) { return EvalPoly(x, c[3]*6.f, c[4]*24.f);                                  }

vec3 EvalCSpline(vec3 p1, vec3 t1, vec3 p2, vec3 t2, float l)
{
	vec3 h1 = p1 + t1 / 3.0;
	vec3 h2 = p2 - t2 / 3.0;
	
	vec3 a1 = mix(p1, h1, l);
	vec3 a2 = mix(h1, h2, l);
	vec3 a3 = mix(h2, p2, l);
	
	vec3 b1 = mix(a1, a2, l);
	vec3 b2 = mix(a2, a3, l);
	
	return mix(b1, b2, l);
}

#define DEF_SplitCurve0(T)						\
void SplitCurve0(T v0, T d0, T v1, T d1,		\
	out T v00_out, out T h0_out, out T v10_out)	\
{												\
	v00_out = v0;								\
	h0_out = v0 + d0 * 0.2667/*ONE_OVER_THREE*/;	\
	const T h1 = v1 - d1 * 0.2667/*ONE_OVER_THREE*/;	\
	v10_out = (h0_out + h1) * 0.5;				\
}

#define DEF_SplitCurve1(T)						\
void SplitCurve1(T v0, T d0, T v1, T d1,		\
	out T v01_out, out T h1_out, out T v11_out)	\
{												\
	const T h0 = v0 + d0 * 0.2667/*ONE_OVER_THREE*/;	\
	h1_out = v1 - d1 * 0.2667/*ONE_OVER_THREE*/;	\
	v01_out = (h0 + h1_out) * 0.5;				\
	v11_out = v1;								\
}

DEF_SplitCurve0(float)
DEF_SplitCurve0(vec3)
DEF_SplitCurve1(float)
DEF_SplitCurve1(vec3)

#define SPLIT_CURVE0(TUBE, MEM_V, MEM_D, QTUBE)				\
SplitCurve0(												\
	TUBE.s.MEM_V, TUBE.s.MEM_D, TUBE.e.MEM_V, TUBE.e.MEM_D,	\
	QTUBE.s.MEM_V, QTUBE.h.MEM_V, QTUBE.e.MEM_V				\
)
#define SPLIT_CURVE1(TUBE, MEM_V, MEM_D, QTUBE)				\
SplitCurve1(												\
	TUBE.s.MEM_V, TUBE.s.MEM_D, TUBE.e.MEM_V, TUBE.e.MEM_D,	\
	QTUBE.s.MEM_V, QTUBE.h.MEM_V, QTUBE.e.MEM_V				\
)

void SplitTube0(Tube tube, out QTube qTube)
{
	SPLIT_CURVE0(tube, pos, pos_tan, qTube);
	SPLIT_CURVE0(tube, rad, rad_tan, qTube);
}
void SplitTube1(Tube tube, out QTube qTube)
{
	SPLIT_CURVE1(tube, pos, pos_tan, qTube);
	SPLIT_CURVE1(tube, rad, rad_tan, qTube);
}

#ifdef PRIMITIVE_RUSSIG

// static options
#define ITERATION_COUNT 10

#define DEF_FINDROOTS(N, D)                                                                         \
void FindRoots##D(float poly_C[N1], float x_i[N], int m_i[N], out float x_o[N+1], out int m_o[N+1]) \
{	                                                                                                \
    m_o[0] = m_o[N] = 1;                                                                            \
	x_o[0] = x_i[0];                                                                                \
	                                                                                                \
	uint j = 0;                                                                                     \
	                                                                                                \
	float x_l = x_i[0];                                                                             \
	float y_l = EvalPoly##D(x_l, poly_C);                                                           \
	float sy_l = sign(y_l);                                                                         \
                                                                                                    \
	for(uint i = 1; i < N; ++i) {                                                                   \
		float x_r = x_i[i];                                                                         \
		float y_r = EvalPoly##D(x_r, poly_C);                                                       \
		float sy_r = sign(y_r);                                                                     \
		                                                                                            \
		x_o[i] = 0.0;                                                                               \
		                                                                                            \
		if(m_i[i] == 1) {                                                                           \
			if(sy_l != sy_r) {                                                                      \
				float n = x_l;                                                                      \
				float p = x_r;                                                                      \
				float ny = EvalPoly##D(n, poly_C);                                                  \
				float py = EvalPoly##D(p, poly_C);                                                  \
				                                                                                    \
				if(ny > 0.0 && py < 0.0) {                                                          \
					float t = n;                                                                    \
					n = p; p = t;                                                                   \
				}                                                                                   \
				                                                                                    \
				for(uint j = 0; j < ITERATION_COUNT; ++j) {                                         \
					float m = (n + p) * 0.5;                                                        \
					float f = EvalPoly##D(m, poly_C);                                               \
					                                                                                \
					if(f < 0.0) n = m;                                                              \
					else p = m;                                                                     \
				}                                                                                   \
				                                                                                    \
				x_o[i] = (n + p) * 0.5;                                                             \
                                                                                                    \
				m_o[i] = 1;                                                                         \
			} else {			                                                                    \
				m_o[i] = 0;                                                                         \
			}                                                                                       \
			                                                                                        \
			x_l = x_r;                                                                              \
			y_l = y_r;                                                                              \
			sy_l = sy_r;                                                                            \
		} else {                                                                                    \
			m_o[i] = 0;                                                                             \
		}                                                                                           \
	}                                                                                               \
	                                                                                                \
	x_o[N] = x_i[N - 1];                                                                            \
}
DEF_FINDROOTS(4, D1)
DEF_FINDROOTS(5, D0)

#endif // ifdef PRIMITIVE_RUSSIG


void SplinePointsToPolyCoeffs(float p0, float h, float p1, out float o_c[3])
{
	o_c[0] = p0;
	o_c[1] = -2.0 * p0 + 2.0 * h;
	o_c[2] =   p0 + p1 - 2.0 * h;
}

vec3 qSplineEval(float l, float curveX[N0], float curveY[N0], float curveZ[N0])
{
	return vec3(
		EvalPolyD0(l, curveX), 
		EvalPolyD0(l, curveY), 
		EvalPolyD0(l, curveZ)
	);
}

vec3 qSplineTangent(float l, float curveX[N0], float curveY[N0], float curveZ[N0])
{
	return vec3(
		EvalPolyD1(l, curveX), 
		EvalPolyD1(l, curveY), 
		EvalPolyD1(l, curveZ)
	);
}

float qSplineIDistEval(float t, float curveX[N0], float polyB_C[N1])
{		
	float term  = EvalPolyD0(t, curveX);
	float discr = EvalPolyD0(t, polyB_C);
		
	if(discr < 0.0) return POS_INF;
	else return term - sqrt(discr);
}

#define qSplineIDist_ParasDec float curveX[N0], float polyB_C[N1]
#define qSplineIDist_Paras curveX, polyB_C

float qSplineD1Eval(float t, float curveX[N0], float polyB_C[N1])
{	 		
	float f1D1 = EvalPolyD1(t, curveX);	
	float f2D0 = EvalPolyD0(t, polyB_C);
	float f2D1 = EvalPolyD1(t, polyB_C);

	return f1D1 - f2D1 * 0.5 * inversesqrt(max(0.0, f2D0));
}

#define qSplineD1_ParasDec float curveX[N0], float polyB_C[N1]
#define qSplineD1_Paras curveX, polyB_C

float qSplineD2Eval(float t, float curveX[N0], float polyB_C[N1])
{		
	float f1D1 = EvalPolyD1(t, curveX);
	float f1D2 = EvalPolyD2(t, curveX);
		
	float f2D0 = EvalPolyD0(t, polyB_C);
	float f2D1 = EvalPolyD1(t, polyB_C);
	float f2D2 = EvalPolyD2(t, polyB_C);
	
	f2D0 = max(0.0, f2D0);
	
	return (Pow2(f2D1) / f2D0 * 0.25 - f2D2 * 0.5) * inversesqrt(f2D0) + f1D2;
}

#define qSplineD2_ParasDec float curveX[N0], float polyB_C[N1]
#define qSplineD2_Paras curveX, polyB_C

float qSplineD3Eval(float t, float polyB_C[N1])
{
	float f2D0 = EvalPolyD0(t, polyB_C);
	float f2D1 = EvalPolyD1(t, polyB_C);
	float f2D2 = EvalPolyD2(t, polyB_C);
	float f2D3 = EvalPolyD3(t, polyB_C);

	f2D0 = max(0.0, f2D0);

	return (-3.0 * Pow3(f2D1) + 6.0 * f2D0 * f2D1 * f2D2 - 4.0 * Pow2(f2D0) * f2D3) / Pow2(f2D0) * inversesqrt(f2D0);
}

#define qSplineD3_ParasDec float polyB_C[N1]
#define qSplineD3_Paras polyB_C


#ifdef PRIMITIVE_RUSSIG
	#define DEF_binRootFinder(func)                                    \
	float func##_BinRootFinder_Eval(float n, float p, func##_ParasDec) \
	{		                                                           \
		if(func##Eval(n, func##_Paras) > 0.0) return n;                \
		if(func##Eval(p, func##_Paras) < 0.0) return p;		           \
																	   \
		for(uint i = 0; i < ITERATION_COUNT; ++i) {                    \
			float m = (n + p) * 0.5;                                   \
			float f = func##Eval(m, func##_Paras);                     \
																	   \
			if(f < 0.0) n = m;                                         \
			else p = m;                                                \
		}                                                              \
																	   \
		return (n + p) * 0.5;                                          \
	}

	DEF_binRootFinder(qSplineIDist)
	DEF_binRootFinder(qSplineD1)
	DEF_binRootFinder(qSplineD2)
	DEF_binRootFinder(qSplineD3)

	#define binRootFinder_Eval(n, p, func) func##_BinRootFinder_Eval(n, p, func##_Paras)

#elif defined(PRIMITIVE_PHANTOM)
	// static options
	#define MAX_ITERATIONS 24
	#define TOLERANCE 0.000244140625f  // = 2^-12

	float dist_to_line (const vec3 s, const vec3 t, const vec3 pt)
	{
		return length(cross(pt-s, pt-t)) / length(t-s);
	}

	bool intersect_cylinder (const vec3 ray_orig, const vec3 dir, const vec3 p0,
							 const vec3 p1, const float ra)
	{
		vec3 ba = p1 - p0;
		vec3 oc = ray_orig - p0;

		float baba = dot(ba, ba);
		float bard = dot(ba, dir);
		float baoc = dot(ba, oc);

		float k2 = baba - bard * bard;
		float k1 = baba * dot(oc, dir) - baoc * bard;
		float k0 = baba * dot(oc, oc) - baoc * baoc - ra * ra * baba;

		float h = k1 * k1 - k2 * k0;

		if (h < .0f)
			return false;

		h = sqrt(h);
		float t = (-k1 - h) / k2;

		// body
		float y = baoc + t * bard;
		if (y > .0f && y < baba)
			return true;

		// caps
		t = ((y < .0f ? .0f : baba) - baoc) / bard;
		if (abs(k1 + k2 * t) < h)
			return true;

		return false;
	}

	struct RayConeIntersection
	{
		vec3 c0;
		vec3 cd;
		float s;
		float dt;
		float dp;
		float dc;
		float sp;
	};
	bool RayConeIntersect (out RayConeIntersection rci, const float r, const float dr)
	{
		const float r2  = r*r;
		const float rdr = r*dr;

		const float cdd = rci.c0.x * rci.cd.x  +  rci.c0.y * rci.cd.y;
		const float cxd = rci.c0.x * rci.cd.y  -  rci.c0.y * rci.cd.x;
		      float ddd = rci.cd.x * rci.cd.x  +  rci.cd.y * rci.cd.y;
		         rci.dp = rci.c0.x * rci.c0.x  +  rci.c0.y * rci.c0.y;

		const float c = ddd;
		const float b = rci.cd.z * (rdr-cdd);
		const float cdz2 = rci.cd.z * rci.cd.z;
		ddd += cdz2;
		const float a = 2.0f * rdr*cdd + cxd*cxd - ddd*r2 + rci.dp*cdz2;

		const float discr = b*b - a*c;
		rci.s   = (b - (discr > 0 ? sqrt(discr) : 0)) / c;
		rci.dt  = (rci.s*rci.cd.z - cdd) / ddd;
		rci.dc  = rci.s*rci.s + rci.dp;
		rci.sp  = cdd / rci.cd.z;
		rci.dp += rci.sp*rci.sp;

		return discr > .0f;
	}
#endif // ifdef PRIMITIVE_RUSSIG

Hit EvalSplineISect(
	const vec3 dir, const vec3 s, const vec3 h, const vec3 t,
	const float rs, const float rh, const float rt, const float l_max
)
{
	Hit hit;
	hit.l = 0.0;
	hit.t = POS_INF;
	hit.normal = vec3(0.0);
	
	const mat3 RCC =
		#ifdef PRIMITIVE_RUSSIG
			calc_rcc_x(dir);
		#elif defined(PRIMITIVE_PHANTOM)
			calc_rcc_z(dir);
		#endif
	const vec3 s_rcc = s*RCC, h_rcc = h*RCC, t_rcc = t*RCC;

	float curveX[N0]; SplinePointsToPolyCoeffs(s_rcc.x, h_rcc.x, t_rcc.x, curveX);
	float curveY[N0]; SplinePointsToPolyCoeffs(s_rcc.y, h_rcc.y, t_rcc.y, curveY);
	float curveZ[N0]; SplinePointsToPolyCoeffs(s_rcc.z, h_rcc.z, t_rcc.z, curveZ);
	float rcurve[N0]; SplinePointsToPolyCoeffs(rs, rh, rt, rcurve);
	
#ifdef PRIMITIVE_RUSSIG
	float polyB_C[N1];
		
	Pow2(rcurve, polyB_C);

	{ float c[N1];
	  Pow2(curveY, c);
	  Sub(polyB_C, c, polyB_C); }
	{ float c[N1];
	  Pow2(curveZ, c);
	  Sub(polyB_C, c, polyB_C); }
	
	float l1 = 0.0;
	float l2 = 0.0;
	
	vec4 roots = vec4(-1.0);
	
	float x2[4];
	int m2[4];
	
	vec2 r = SolveQuadratic(polyB_C[4] * 12.0, polyB_C[3] * 6.0, polyB_C[2] * 2.0);
	
	x2[0] = 0.0;
	x2[1] = r.x;
	x2[2] = r.y;
	x2[3] = min(l_max, 1.0);

	m2[0] = 1;
	m2[1] = (x2[1] <= x2[0] || x2[1] >= x2[3]) ? 0 : 1;
	m2[2] = (x2[2] <= x2[0] || x2[2] >= x2[3]) ? 0 : 1;
	m2[3] = 1;

	float x3[5];
	int m3[5];
	FindRootsD1(polyB_C, x2, m2, x3, m3);

	float x4[6];
	int m4[6];
	
	{		
		FindRootsD0(polyB_C, x3, m3, x4, m4);

		int rootType = 0;
		int rn = 0;
		
		if(EvalPolyD0(0.0, polyB_C) >= 0.0) {
								  roots.x =  0; rn = 1; rootType = 15;
		}
		
		if(m4[1] == 1) {
			if(rn == 0) 		{ roots.x = x4[1]; rn = 1; rootType = 15;						}
			else				{ roots.y = x4[1]; rn = 2; rootType = 10; 						}	
		} else if(rootType == 15) {
			rootType = 0;
		}
		
		if(m4[2] == 1) {
			if     (rn == 0) 	{ roots.x = x4[2]; rn = 1; rootType = 15;						}
			else if(rn == 1)	{ roots.y = x4[2]; rn = 2; rootType = rootType == 0 ? 30 : 10;	}	
			else 				{ roots.z = x4[2]; rn = 3; rootType = 20; 						}	
		} else if(rootType == 15) {
			rootType = 0;
		}
		
		if(m4[3] == 1) {
			if     (rn == 0) 	{ roots.x = x4[3]; rn = 1; rootType = 15;						}
			else if(rn == 1)	{ roots.y = x4[3]; rn = 2; rootType = rootType == 0 ? 30 : 10;	}	
			else if(rn == 2)	{ roots.z = x4[3]; rn = 3; rootType = 20; 						}	
			else 				{ roots.w = x4[3]; rn = 4; rootType = 20; 						}	
		} else if(rootType == 15) {
			rootType = 0;
		}
		
		if(m4[4] == 1) {
			if     (rn == 0) 	{ roots.x = x4[4]; rn = 1; rootType = 15;						}
			else if(rn == 1)	{ roots.y = x4[4]; rn = 2; rootType = rootType == 0 ? 30 : 10;	}	
			else if(rn == 2)	{ roots.z = x4[4]; rn = 3; rootType = 20; 						}	
			else 				{ roots.w = x4[4]; rn = 4; rootType = 20; 						}	
		} else if(rootType == 15) {
			rootType = 0;
		}
		
		if(EvalPolyD0(x2[3], polyB_C) > 0.0) {
			if     (rn == 1)	{ roots.y =   1.0; rn = 1; rootType = rootType == 0 ? 30 : 10;	}
			else				{ roots.w =   1.0; rn = 2; rootType = 20; 						}	
		}
		
		if(rootType == 10 || rootType == 15) rootType = 30;

		//region finalize
		if(rootType > 0) {
			if(rootType == 30) {
				float rootD3 = binRootFinder_Eval(roots.x, roots.y, qSplineD3);
				
				vec2 rootsD2;
				rootsD2.x = binRootFinder_Eval(rootD3, roots.x, qSplineD2);
				rootsD2.y = binRootFinder_Eval(rootD3, roots.y, qSplineD2);
				
				l1 = binRootFinder_Eval(roots.x, rootsD2.x, qSplineD1);
				l2 = binRootFinder_Eval(rootsD2.y, roots.y, qSplineD1);
			} else {
				l1 = binRootFinder_Eval(roots.x, roots.y, qSplineD1);
				
				if(rootType == 20)
					l2 = binRootFinder_Eval(roots.z, roots.w, qSplineD1);
				else
					l2 = l1;
			}
			
			float t1 = qSplineIDistEval(l1, curveX, polyB_C);
			float t2 = qSplineIDistEval(l2, curveX, polyB_C);
			
			float r1 = EvalPolyD0(l1, rcurve);
			float r2 = EvalPolyD0(l2, rcurve);
			
			bool hit1 = t1 > 0.0 && r1 > 0.0;
			bool hit2 = t2 > 0.0 && r2 > 0.0;
			
			if(hit1) {
				if(t1 < t2 || !hit2) {
					hit.t = t1;
					hit.l = min(l1, x2[3]);
				} else {
					hit.t = t2;
					hit.l = min(l2, x2[3]);
				}
			} else {
				hit.t = t2;
				hit.l = min(l2, x2[3]);
			}

			hit.cap = hit.l <= 0.0 || hit.l >= x2[3];

			// get the position on the spline at l
			hit.sp = qSplineEval(hit.l, curveX, curveY, curveZ);
			// transform from ray space to eye space
			hit.sp = RCC * hit.sp;
			// calculate the intersection point of the ray with the spline tube
			hit.normal = normalize(hit.t*dir - hit.sp);
		}
		//endregion
	}
#else
	/*RayConeIntersection rci;
	rci.c0 = s_rcc;
	rci.cd = t_rcc-s_rcc;
	if (RayConeIntersect(rci, rs, 0))
	{
		hit.t = rci.s + rci.c0.z;
		hit.l = rci.dt;
		hit.cap = hit.l == 0.0 || hit.l == 1.0;
		hit.sp = RCC * (rci.c0 + hit.l*rci.cd);
		hit.normal = normalize(hit.t*dir - hit.sp);
	}*/
	// determine which curve end to start iterating from
	float tstart = dot(t-s, dir) > .0f ? .0f : 1.f;

	// also attempt from the other end in case iteration from selected one fails
	for (int end=0; end<2; end++)
	{
		float t    = tstart;
		float told = .0f;
		float dt1  = .0f;
		float dt2  = .0f;

		RayConeIntersection rci;
		for (int i=0; i<MAX_ITERATIONS; i++)
		{
			rci.c0 = qSplineEval(t, curveX, curveY, curveZ);
			rci.cd = qSplineTangent(t, curveX, curveY, curveZ);
			const bool phantom = !RayConeIntersect(rci, EvalPolyD0(t, rcurve), EvalPolyD1(t, rcurve));

			// check convergence
			if (   !phantom && abs(rci.dt) < TOLERANCE
				&& t > .0f && t < 1.f) // <-- seems necessary to prevent segment transition artifacts (ToDo: investigate!)
			{
				hit.l = rci.s + rci.c0.z;
				hit.t = t;
				hit.sp = RCC * qSplineEval(hit.t, curveX, curveY, curveZ);
				hit.normal = normalize(hit.t*dir - hit.sp);
				return hit;
			}

			rci.dt = min(rci.dt,  .5f);
			rci.dt = max(rci.dt, -.5f);

			dt1 = dt2;
			dt2 = rci.dt;

			// regula falsi
			if (dt1 * dt2 < .0f) {
				// "we use the simplest possible approach by switching
				//  to the bisection every 4th iteration:"
				told = t;
				t = ((i&3) == 0) ? (.5f*(told+t)) : ((dt2*told - dt1*t) / (dt2-dt1));
			}
			else {
				told = t;
				t += rci.dt;
			}

			if (t < .0f || t > 1.f)
				break;
		}

		// re-attempt iteration from the direction of the other end
		tstart = 1.f - tstart;
	}
#endif // ifdef PRIMITIVE_RUSSIG

	return hit;
}


vec3 eval_quadratic_bezier_tangent(QTube qtube, float t)
{
	mat3 Bk; // control point matrix
	Bk[0] = qtube.s.pos;
	Bk[1] = qtube.h.pos;
	Bk[2] = qtube.e.pos;
	
	mat3 Mb; // quadratic bezier matrix
	Mb[0] = vec3( 1,  0,  0);
	Mb[1] = vec3(-2,  2,  0);
	Mb[2] = vec3( 1, -2,  1);

	mat3 M = Bk * Mb;
	
	// quadratic bezier (1, t, t^2)
	// 1st derivative (0, 1, 2t)
	return M * vec3(0.0, 1, 2.0*t);
}

#if USE_CUBIC_TANGENTS == 1
vec3 eval_cubic_hermite_tangent(float t) {
	vec4 tvec = vec4(3.0*t*t, 2.0*t, 1.0, 0.0);
	return (SM_fs * tvec).xyz;
}
#endif

void main()
{
	////
	// Retrieve segment curve data

	#if ATTRIB_MODE > 0
		const node_data_type n0 = nodes[node_ids[segment_id_fs].x];
		const node_data_type n1 = nodes[node_ids[segment_id_fs].y];
		const float n0_t=n0.t.x, n1_t=n1.t.x;
		vec3 color0, color1;

		#if ATTRIB_MODE & 1
			// compile hermite tube info
			Tube tube;
			tube.s.pos = n0.pos_rad.xyz;
			tube.s.rad = n0.pos_rad.w * radius_scale;
			tube.s.pos_tan = n0.tangent.xyz;
			tube.s.rad_tan = n0.tangent.w;

			tube.e.pos = n1.pos_rad.xyz;
			tube.e.rad = n1.pos_rad.w * radius_scale;
			tube.e.pos_tan = n1.tangent.xyz;
			tube.e.rad_tan = n1.tangent.w;

			// prepare for quadratic split further down
			const mat4 MV = get_modelview_matrix();
			QTube qtube;
		#else
			const QTube qtube = qTube_fs;
		#endif
		if (l_offset_fs == 0) // Select "our" quadratic sub segment
		{
		#if ATTRIB_MODE & 1
			// perform quadratic split
			SplitTube0(tube, qtube);
			qtube.s.pos = (MV * vec4(qtube.s.pos, 1.0)).xyz;
			qtube.h.pos = (MV * vec4(qtube.h.pos, 1.0)).xyz;
			qtube.e.pos = (MV * vec4(qtube.e.pos, 1.0)).xyz;
			qtube.s.rad = qtube.s.rad;
			qtube.h.rad = qtube.h.rad;
			qtube.e.rad = qtube.e.rad;
		#endif
		}
		else
		{
		#if ATTRIB_MODE & 1
			// perform quadratic split
			SplitTube1(tube, qtube);
			qtube.s.pos = (MV * vec4(qtube.s.pos, 1.0)).xyz;
			qtube.h.pos = (MV * vec4(qtube.h.pos, 1.0)).xyz;
			qtube.e.pos = (MV * vec4(qtube.e.pos, 1.0)).xyz;
			qtube.s.rad = qtube.s.rad;
			qtube.h.rad = qtube.h.rad;
			qtube.e.rad = qtube.e.rad;
		#endif
		}
		#if ATTRIB_MODE & 2
			// fetch color from SBO
			color0 = n0.color.rgb;
			color1 = n1.color.rgb;
		#endif
	#else
		const QTube qtube = qTube_fs;
		const float n0_t = nodes[node_ids[segment_id_fs].x].t.x,
		            n1_t = nodes[node_ids[segment_id_fs].y].t.x;
	#endif

#if MODE == 0
	discard;
	return;
#elif MODE == 1
	frag_albedo = vec4(uintBitsToFloat(0xFF0000FF), 0.0, 0.0, intBitsToFloat(0));
	frag_position = vec3(0.0, 0.0, 1.0);
	frag_normal = vec3(0.0, 0.0, 1.0);
	frag_tangent = vec3(1.0, 0.0, 0.0);
	return;
#else

#if USE_VIEW_SPACE_POSITION == 0
	// transform fragment coordinates from window coordinates to clip coordinates
    vec4 coord = gl_FragCoord 
        * vec4(2.0 / viewport.z, 2.0 / viewport.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);

    // transform fragment coordinates from clip coordinates to eye coordinates
    coord = get_inverse_projection_matrix() * coord;
    coord /= coord.w;

    // calculate the viewing ray
    vec3 direction = normalize(coord.xyz);
#else
	vec3 direction = normalize(position_fs);
#endif

	// determine tmax threshold within this segment's parameter space
	const float l_max_cubic = (max_t - n0_t)/(n1_t - n0_t);
	const float l_max = l_offset_fs > 0.0 ? 2*(l_max_cubic - 0.5) : l_max_cubic + l_max_cubic;
	Hit hit = EvalSplineISect(direction,
		qtube.s.pos, qtube.h.pos, qtube.e.pos,
		qtube.s.rad, qtube.h.rad, qtube.e.rad,
		l_max
	);

#if MODE == 3
	gl_FragDepth = 1.0;
#endif

	if(hit.t == POS_INF || (hit.cap && hit.t > cap_clip_distance)) {
#if MODE == 2
		frag_albedo = vec4(uintBitsToFloat(0xFF0000FF), 0.0, 0.0, intBitsToFloat(0));
		frag_position = vec3(0.0, 0.0, 1.0);
		frag_normal = vec3(0.0, 0.0, 1.0);
		frag_tangent = vec3(1.0, 0.0, 0.0);
#else
		discard;
#endif
	} else {
		vec3 hit_pos_eye = direction * hit.t;
		float spline_t = hit.l * 0.5 + l_offset_fs;
		// determine color - since we ignore the tangents, interpolation is just linear
		const vec4 col = spline_t >= max_t ? vec4(0.75, 0.75, 0.75, 1) :
		#if ATTRIB_MODE & 2
			vec4(mix(color0, color1, spline_t), 1.0);
		#else
			vec4(mix(unpackUnorm4x8(color0_fs).rgb, unpackUnorm4x8(color1_fs).rgb, spline_t), 1.0);
		#endif

		vec4 v_eye = vec4(hit_pos_eye, 1.0);
		vec4 depth = get_projection_matrix() * v_eye;
		gl_FragDepth = 0.5*(depth.z / depth.w) + 0.5;

#if USE_CUBIC_TANGENTS == 0
		// tangent is already given in eye space
		vec3 tangent = normalize(eval_quadratic_bezier_tangent(qtube, hit.l));
#else
		// tangent is given in object space
		vec3 tangent = eval_cubic_hermite_tangent(spline_t);
		// transform the tangent from object space to eye space
		tangent = normalize(get_normal_matrix() * tangent);
#endif
		// calculate a bitangent which is orthogonal to the plane defined by the tangent and the vector from the eye position to the hit position
		vec3 b = normalize(cross(tangent, hit.sp-(get_modelview_matrix()*vec4(eye_pos,1)).xyz));
		// the texture coordinate around the tubes perimeter is the acos of the dot product between the normal and the bitangent
		// normalized to [0,1]
		// since we are only interested in the eye-facing side of the tube, acos is sufficient here
		float v = acos(dot(b, hit.normal)) * M_INV_PI;

		//frag_albedo = vec4(uintBitsToFloat(packUnorm4x8(col)), spline_t, v, intBitsToFloat(segment_id_fs));
		frag_albedo = vec4(uintBitsToFloat(packUnorm4x8(col)), alen(spline_t), v, intBitsToFloat(segment_id_fs));
		frag_position = vec3(hit_pos_eye);
		frag_normal = hit.normal;
		frag_tangent = tangent;
	}
#endif
}
