#version 430

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

uniform sampler3D input_tex;
//layout(r32f, binding = 0) uniform readonly image3D input_tex;
layout(r32f, binding = 1) uniform writeonly image3D output_tex;

uniform uint level;
uniform ivec3 output_res;

void main() {
	// The address of the output voxel.
    ivec3 idx = ivec3(gl_GlobalInvocationID);
    
	// This produces correct results even for odd sized input textures.
	if(idx.x < output_res.x && idx.y < output_res.y && idx.z < output_res.z) {
		float result = 0.0;

		vec3 output_res_f = vec3(output_res);
		vec3 double_res = 2.0 * (output_res_f);

		vec3 fidx = idx / output_res_f;
		vec3 fstep = 1.0 / double_res;
		fidx += 0.5 * fstep;

		// Use texture sampler filtering to average samples.
		result += textureLod(input_tex, fidx + vec3(0.0, 0.0, 0.0), level).r;
		result += textureLod(input_tex, fidx + vec3(0.0, 0.0, fstep.z), level).r;

		result += textureLod(input_tex, fidx + vec3(0.0, fstep.y, 0.0), level).r;
		result += textureLod(input_tex, fidx + vec3(0.0, fstep.y, fstep.z), level).r;

		result += textureLod(input_tex, fidx + vec3(fstep.x, 0.0, 0.0), level).r;
		result += textureLod(input_tex, fidx + vec3(fstep.x, 0.0, fstep.z), level).r;

		result += textureLod(input_tex, fidx + vec3(fstep.x, fstep.y, 0.0), level).r;
		result += textureLod(input_tex, fidx + vec3(fstep.x, fstep.y, fstep.z), level).r;

		result /= 8.0;

		imageStore(output_tex, idx, vec4(result));
	}
}
